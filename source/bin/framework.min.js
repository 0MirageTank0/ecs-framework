window.framework = {}, window.__extends = this && this.__extends || function() {
  var t =
      Object.setPrototypeOf ||
      {__proto__ : []} instanceof Array && function(t, e) { t.__proto__ = e } ||
      function(t, e) {
        for (var n in e)
          e.hasOwnProperty(n) && (t[n] = e[n])
      };
  return function(e, n) {
    function i() { this.constructor = e }
    t(e, n), e.prototype = null === n ? Object.create(n)
                                      : (i.prototype = n.prototype, new i)
  }
}();
var __awaiter = this && this.__awaiter || function(t, e, n, i) {
  return new (n || (n = Promise))(function(o, r) {
    function s(t) {
      try {
        h(i.next(t))
      } catch (t) {
        r(t)
      }
    }
    function a(t) {
      try {
        h(i.throw(t))
      } catch (t) {
        r(t)
      }
    }
    function h(t) {
      t.done ? o(t.value) : new n(function(e) { e(t.value) }).then(s, a)
    }
    h((i = i.apply(t, e || [])).next())
  })
}, __generator = this && this.__generator || function(t, e) {
  var n, i, o, r, s = {
    label : 0,
    sent : function() {
      if (1 & o[0])
        throw o[1];
      return o[1]
    },
    trys : [],
    ops : []
  };
  return r = {next : a(0), throw : a(1), return : a(2)},
         "function" == typeof Symbol &&
             (r[Symbol.iterator] = function() { return this }),
         r;
  function a(r) {
    return function(a) {
      return function(r) {
        if (n)
          throw new TypeError("Generator is already executing.");
        for (; s;)
          try {
            if (n = 1,
                i &&
                    (o = 2 & r[0] ? i.return : r[0] ? i.throw || ((o = i.return ) && o.call(i), 0) : i.next) &&
                    !(o = o.call(i, r[1])).done)
              return o;
            switch (i = 0, o && (r = [ 2 & r[0], o.value ]), r[0]) {
            case 0:
            case 1:
              o = r;
              break;
            case 4:
              return s.label++, {value : r[1], done : !1};
            case 5:
              s.label++, i = r[1], r = [ 0 ];
              continue;
            case 7:
              r = s.ops.pop(), s.trys.pop();
              continue;
            default:
              if (!(o = (o = s.trys).length > 0 && o[o.length - 1]) &&
                  (6 === r[0] || 2 === r[0])) {
                s = 0;
                continue
              }
              if (3 === r[0] && (!o || r[1] > o[0] && r[1] < o[3])) {
                s.label = r[1];
                break
              }
              if (6 === r[0] && s.label < o[1]) {
                s.label = o[1], o = r;
                break
              }
              if (o && s.label < o[2]) {
                s.label = o[2], s.ops.push(r);
                break
              }
              o[2] && s.ops.pop(), s.trys.pop();
              continue
            }
            r = e.call(t, s)
          } catch (t) {
            r = [ 6, t ], i = 0
          } finally {
            n = o = 0
          }
        if (5 & r[0])
          throw r[1];
        return { value: r[0] ? r[1] : void 0, done: !0 }
      }([ r, a ])
    }
  }
};
Array.prototype.findIndex =
    function(t) {
  return function(t, e) {
    for (var n = 0, i = t.length; n < i; n++)
      if (e.call(arguments[2], t[n], n, t))
        return n;
    return -1
  }(this, t)
},
    Array.prototype.any = function(
        t) { return function(t, e) { return t.findIndex(e) > -1 }(this, t) },
    Array.prototype.firstOrDefault =
        function(t) {
      return function(t, e) {
        var n = t.findIndex(e);
        return -1 == n ? null : t[n]
      }(this, t)
    },
    Array.prototype.find = function(
        t) { return function(t, e) { return t.firstOrDefault(e) }(this, t) },
    Array.prototype.where =
        function(t) {
      return function(t, e) {
        if ("function" == typeof t.reduce)
          return t.reduce(function(n, i, o) {
            return e.call(arguments[2], i, o, t) && n.push(i), n
          }, []);
        for (var n = [], i = 0, o = t.length; i < o; i++) {
          var r = t[i];
          e.call(arguments[2], r, i, t) && n.push(r)
        }
        return n
      }(this, t)
    },
    Array.prototype.count = function(
        t) { return function(t, e) { return t.where(e).length }(this, t) },
    Array.prototype.findAll = function(
        t) { return function(t, e) { return t.where(e) }(this, t) },
    Array.prototype.contains = function(t) {
      return function(t, e) {
        for (var n = 0, i = t.length; n < i; n++)
          if (t[n] == e)
            return !0;
        return !1
      }(this, t)
    }, Array.prototype.removeAll = function(t) {
      !function(t, e) {
        var n;
        do {
          (n = t.findIndex(e)) >= 0 && t.splice(n, 1)
        } while (n >= 0)
      }(this, t)
    }, Array.prototype.remove = function(t) {
      return function(t, e) {
        var n = t.findIndex(function(t) { return t === e });
        return n >= 0 && (t.splice(n, 1), !0)
      }(this, t)
    }, Array.prototype.removeAt = function(t) {
      return function(t, e) { t.splice(e, 1) }(this, t)
    }, Array.prototype.removeRange = function(t, e) {
      return function(t, e, n) { t.splice(e, n) }(this, t, e)
    }, Array.prototype.select = function(t) {
      return function(t, e) {
        if ("function" == typeof t.reduce)
          return t.reduce(function(n, i, o) {
            return n.push(e.call(arguments[2], i, o, t)), n
          }, []);
        for (var n = [], i = 0, o = t.length; i < o; i++)
          n.push(e.call(arguments[2], t[i], i, t));
        return n
      }(this, t)
    }, Array.prototype.orderBy = function(t, e) {
      return function(t, e, n) {
        return t.sort(function(t, i) {
          var o = e(t), r = e(i);
          return n ? n(o, r) : o > r ? 1 : -1
        }),
               t
      }(this, t, e)
    }, Array.prototype.orderByDescending = function(t, e) {
      return function(t, e, n) {
        return t.sort(function(t, i) {
          var o = e(t), r = e(i);
          return n ? -n(o, r) : o < r ? 1 : -1
        }),
               t
      }(this, t, e)
    }, Array.prototype.groupBy = function(t) {
      return function(t, e) {
        if ("function" == typeof t.reduce) {
          var n = [];
          return t.reduce(function(i, o, r) {
            var s = JSON.stringify(e.call(arguments[1], o, r, t)),
                a = n.findIndex(function(t) { return t === s });
            return a < 0 && (a = n.push(s) - 1), i[a] || (i[a] = []),
                   i[a].push(o), i
          }, [])
        }
        for (var i = [], o = [], r = function(n, r) {
               var a = JSON.stringify(e.call(s[1], t[n], n, t)),
                   h = o.findIndex(function(t) { return t === a });
               h < 0 && (h = o.push(a) - 1), i[h] || (i[h] = []),
                   i[h].push(t[n])
             }, s = arguments, a = 0, h = t.length; a < h; a++)
          r(a);
        return i
      }(this, t)
    }, Array.prototype.sum = function(t) {
      return function(t, e) {
        for (var n, i = 0, o = t.length; i < o; i++)
          0 == i ? n = e ? e.call(arguments[2], t[i], i, t) : t[i]
                 : n += e ? e.call(arguments[2], t[i], i, t) : t[i];
        return n
      }(this, t)
    };
var DirtyType, ComponentTransform, PriorityQueueNode = function() {
  return function() {
    this.priority = 0, this.insertionIndex = 0, this.queueIndex = 0
  }
}(), AStarPathfinder = function() {
  function t() {}
  return t.search = function(t, e, n) {
    var i = this, o = !1, r = new Map;
    r.set(e, e);
    var s = new Map, a = new PriorityQueue(1e3);
    a.enqueue(new AStarNode(e), 0), s.set(e, 0);
    for (var h = function() {
           var e = a.dequeue();
           if (JSON.stringify(e.data) == JSON.stringify(n))
             return o = !0, "break";
           t.getNeighbors(e.data).forEach(function(o) {
             var h = s.get(e.data) + t.cost(e.data, o);
             if (!i.hasKey(s, o) || h < s.get(o)) {
               s.set(o, h);
               var c = h + t.heuristic(o, n);
               a.enqueue(new AStarNode(o), c), r.set(o, e.data)
             }
           })
         }; a.count > 0;) {
      if ("break" === h())
        break
    }
    return o ? this.recontructPath(r, e, n) : null
  }, t.hasKey = function(t, e) {
    for (var n, i = t.keys(); !(n = i.next()).done;)
      if (JSON.stringify(n.value) == JSON.stringify(e))
        return !0;
    return !1
  }, t.getKey = function(t, e) {
    for (var n, i, o = t.keys(), r = t.values();
         n = o.next(), i = r.next(), !n.done;)
      if (JSON.stringify(n.value) == JSON.stringify(e))
        return i.value;
    return null
  }, t.recontructPath = function(t, e, n) {
    var i = [], o = n;
    for (i.push(n); o != e;)
      o = this.getKey(t, o), i.push(o);
    return i.reverse(), i
  }, t
}(), AStarNode = function(t) {
  function e(e) {
    var n = t.call(this) || this;
    return n.data = e, n
  }
  return __extends(e, t), e
}(PriorityQueueNode), AstarGridGraph = function() {
  function t(t, e) {
    this.dirs =
        [
          new Point(1, 0), new Point(0, -1), new Point(-1, 0), new Point(0, 1)
        ],
    this.walls = [], this.weightedNodes = [], this.defaultWeight = 1,
    this.weightedNodeWeight = 5, this._neighbors = new Array(4),
    this._width = t, this._height = e
  }
  return t.prototype.isNodeInBounds = function(t) {
    return 0 <= t.x && t.x < this._width && 0 <= t.y && t.y < this._height
  }, t.prototype.isNodePassable = function(t) {
    return !this.walls.firstOrDefault(function(
        e) { return JSON.stringify(e) == JSON.stringify(t) })
  }, t.prototype.search = function(t, e) {
    return AStarPathfinder.search(this, t, e)
  }, t.prototype.getNeighbors = function(t) {
    var e = this;
    return this._neighbors.length = 0, this.dirs.forEach(function(n) {
      var i = new Point(t.x + n.x, t.y + n.y);
      e.isNodeInBounds(i) && e.isNodePassable(i) && e._neighbors.push(i)
    }),
           this._neighbors
  }, t.prototype.cost = function(t, e) {
    return this.weightedNodes.find(function(
               t) { return JSON.stringify(t) == JSON.stringify(e) })
               ? this.weightedNodeWeight
               : this.defaultWeight
  }, t.prototype.heuristic = function(t, e) {
    return Math.abs(t.x - e.x) + Math.abs(t.y - e.y)
  }, t
}(), PriorityQueue = function() {
  function t(t) {
    this._numNodes = 0, this._nodes = new Array(t + 1),
    this._numNodesEverEnqueued = 0
  }
  return t.prototype.clear =
             function() {
    this._nodes.splice(1, this._numNodes), this._numNodes = 0
  },
         Object.defineProperty(t.prototype, "count", {
           get : function() { return this._numNodes },
           enumerable : !0,
           configurable : !0
         }),
         t.prototype.contains = function(
             t) { return this._nodes[t.queueIndex] == t },
         t.prototype.enqueue = function(t, e) {
           t.priority = e, this._numNodes++, this._nodes[this._numNodes] = t,
           t.queueIndex = this._numNodes,
           t.insertionIndex = this._numNodesEverEnqueued++,
           this.cascadeUp(this._nodes[this._numNodes])
         }, t.prototype.dequeue = function() {
           var t = this._nodes[1];
           return this.remove(t), t
         }, t.prototype.remove = function(t) {
           if (t.queueIndex == this._numNodes)
             return this._nodes[this._numNodes] = null, void this._numNodes--;
           var e = this._nodes[this._numNodes];
           this.swap(t, e), delete this._nodes[this._numNodes],
               this._numNodes--, this.onNodeUpdated(e)
         }, t.prototype.isValidQueue = function() {
           for (var t = 1; t < this._nodes.length; t++)
             if (this._nodes[t]) {
               var e = 2 * t;
               if (e < this._nodes.length && this._nodes[e] &&
                   this.hasHigherPriority(this._nodes[e], this._nodes[t]))
                 return !1;
               var n = e + 1;
               if (n < this._nodes.length && this._nodes[n] &&
                   this.hasHigherPriority(this._nodes[n], this._nodes[t]))
                 return !1
             }
           return !0
         }, t.prototype.onNodeUpdated = function(t) {
           var e = Math.floor(t.queueIndex / 2), n = this._nodes[e];
           e > 0 && this.hasHigherPriority(t, n) ? this.cascadeUp(t)
                                                 : this.cascadeDown(t)
         }, t.prototype.cascadeDown = function(t) {
           for (var e, n = t.queueIndex;;) {
             e = t;
             var i = 2 * n;
             if (i > this._numNodes) {
               t.queueIndex = n, this._nodes[n] = t;
               break
             }
             var o = this._nodes[i];
             this.hasHigherPriority(o, e) && (e = o);
             var r = i + 1;
             if (r <= this._numNodes) {
               var s = this._nodes[r];
               this.hasHigherPriority(s, e) && (e = s)
             }
             if (e == t) {
               t.queueIndex = n, this._nodes[n] = t;
               break
             }
             this._nodes[n] = e;
             var a = e.queueIndex;
             e.queueIndex = n, n = a
           }
         }, t.prototype.cascadeUp = function(t) {
           for (var e = Math.floor(t.queueIndex / 2); e >= 1;) {
             var n = this._nodes[e];
             if (this.hasHigherPriority(n, t))
               break;
             this.swap(t, n), e = Math.floor(t.queueIndex / 2)
           }
         }, t.prototype.swap = function(t, e) {
           this._nodes[t.queueIndex] = e, this._nodes[e.queueIndex] = t;
           var n = t.queueIndex;
           t.queueIndex = e.queueIndex, e.queueIndex = n
         }, t.prototype.hasHigherPriority = function(t, e) {
           return t.priority < e.priority ||
                  t.priority == e.priority &&
                      t.insertionIndex < e.insertionIndex
         }, t
}(), BreadthFirstPathfinder = function() {
  function t() {}
  return t.search = function(t, e, n) {
    var i = this, o = !1, r = [];
    r.unshift(e);
    var s = new Map;
    s.set(e, e);
    for (var a = function() {
           var e = r.shift();
           if (JSON.stringify(e) == JSON.stringify(n))
             return o = !0, "break";
           t.getNeighbors(e).forEach(function(
               t) { i.hasKey(s, t) || (r.unshift(t), s.set(t, e)) })
         }; r.length > 0;) {
      if ("break" === a())
        break
    }
    return o ? AStarPathfinder.recontructPath(s, e, n) : null
  }, t.hasKey = function(t, e) {
    for (var n, i = t.keys(); !(n = i.next()).done;)
      if (JSON.stringify(n.value) == JSON.stringify(e))
        return !0;
    return !1
  }, t
}(), UnweightedGraph = function() {
  function t() { this.edges = new Map }
  return t.prototype.addEdgesForNode = function(
             t, e) { return this.edges.set(t, e), this },
         t.prototype.getNeighbors = function(t) { return this.edges.get(t) }, t
}(), Point = function() {
  return function(t, e) { this.x = t || 0, this.y = e || this.x }
}(), UnweightedGridGraph = function() {
  function t(e, n, i) {
    void 0 === i && (i = !1), this.walls = [], this._neighbors = new Array(4),
                              this._width = e, this._hegiht = n,
                              this._dirs = i ? t.COMPASS_DIRS : t.CARDINAL_DIRS
  }
  return t.prototype.isNodeInBounds =
             function(t) {
    return 0 <= t.x && t.x < this._width && 0 <= t.y && t.y < this._hegiht
  },
         t.prototype.isNodePassable =
             function(t) {
           return !this.walls.firstOrDefault(function(
               e) { return JSON.stringify(e) == JSON.stringify(t) })
         },
         t.prototype.getNeighbors =
             function(t) {
           var e = this;
           return this._neighbors.length = 0, this._dirs.forEach(function(n) {
             var i = new Point(t.x + n.x, t.y + n.y);
             e.isNodeInBounds(i) && e.isNodePassable(i) && e._neighbors.push(i)
           }),
                  this._neighbors
         },
         t.prototype.search = function(
             t, e) { return BreadthFirstPathfinder.search(this, t, e) },
         t.CARDINAL_DIRS =
             [
               new Point(1, 0), new Point(0, -1), new Point(-1, 0),
               new Point(0, -1)
             ],
         t.COMPASS_DIRS =
             [
               new Point(1, 0), new Point(1, -1), new Point(0, -1),
               new Point(-1, -1), new Point(-1, 0), new Point(-1, 1),
               new Point(0, 1), new Point(1, 1)
             ],
         t
}(), WeightedGridGraph = function() {
  function t(e, n, i) {
    void 0 === i && (i = !1),
        this.walls = [], this.weightedNodes = [], this.defaultWeight = 1,
        this.weightedNodeWeight = 5, this._neighbors = new Array(4),
        this._width = e, this._height = n,
        this._dirs = i ? t.COMPASS_DIRS : t.CARDINAL_DIRS
  }
  return t.prototype.isNodeInBounds =
             function(t) {
    return 0 <= t.x && t.x < this._width && 0 <= t.y && t.y < this._height
  },
         t.prototype.isNodePassable =
             function(t) {
           return !this.walls.firstOrDefault(function(
               e) { return JSON.stringify(e) == JSON.stringify(t) })
         },
         t.prototype.search = function(
             t, e) { return WeightedPathfinder.search(this, t, e) },
         t.prototype.getNeighbors =
             function(t) {
           var e = this;
           return this._neighbors.length = 0, this._dirs.forEach(function(n) {
             var i = new Point(t.x + n.x, t.y + n.y);
             e.isNodeInBounds(i) && e.isNodePassable(i) && e._neighbors.push(i)
           }),
                  this._neighbors
         },
         t.prototype.cost =
             function(t, e) {
           return this.weightedNodes.find(function(
                      t) { return JSON.stringify(t) == JSON.stringify(e) })
                      ? this.weightedNodeWeight
                      : this.defaultWeight
         },
         t.CARDINAL_DIRS =
             [
               new Point(1, 0), new Point(0, -1), new Point(-1, 0),
               new Point(0, 1)
             ],
         t.COMPASS_DIRS =
             [
               new Point(1, 0), new Point(1, -1), new Point(0, -1),
               new Point(-1, -1), new Point(-1, 0), new Point(-1, 1),
               new Point(0, 1), new Point(1, 1)
             ],
         t
}(), WeightedNode = function(t) {
  function e(e) {
    var n = t.call(this) || this;
    return n.data = e, n
  }
  return __extends(e, t), e
}(PriorityQueueNode), WeightedPathfinder = function() {
  function t() {}
  return t.search = function(t, e, n) {
    var i = this, o = !1, r = new Map;
    r.set(e, e);
    var s = new Map, a = new PriorityQueue(1e3);
    a.enqueue(new WeightedNode(e), 0), s.set(e, 0);
    for (var h = function() {
           var e = a.dequeue();
           if (JSON.stringify(e.data) == JSON.stringify(n))
             return o = !0, "break";
           t.getNeighbors(e.data).forEach(function(n) {
             var o = s.get(e.data) + t.cost(e.data, n);
             if (!i.hasKey(s, n) || o < s.get(n)) {
               s.set(n, o);
               var h = o;
               a.enqueue(new WeightedNode(n), h), r.set(n, e.data)
             }
           })
         }; a.count > 0;) {
      if ("break" === h())
        break
    }
    return o ? this.recontructPath(r, e, n) : null
  }, t.hasKey = function(t, e) {
    for (var n, i = t.keys(); !(n = i.next()).done;)
      if (JSON.stringify(n.value) == JSON.stringify(e))
        return !0;
    return !1
  }, t.getKey = function(t, e) {
    for (var n, i, o = t.keys(), r = t.values();
         n = o.next(), i = r.next(), !n.done;)
      if (JSON.stringify(n.value) == JSON.stringify(e))
        return i.value;
    return null
  }, t.recontructPath = function(t, e, n) {
    var i = [], o = n;
    for (i.push(n); o != e;)
      o = this.getKey(t, o), i.push(o);
    return i.reverse(), i
  }, t
}(), DebugDefaults = function() {
  function t() {}
  return t.verletParticle = 14431326, t.verletConstraintEdge = 4406838, t
}(), Component = function(t) {
  function e() {
    var e = null !== t && t.apply(this, arguments) || this;
    return e._enabled = !0, e.updateInterval = 1, e
  }
  return __extends(e, t), Object.defineProperty(e.prototype, "enabled", {
    get : function() {
      return this.entity ? this.entity.enabled && this._enabled : this._enabled
    },
    set : function(t) { this.setEnabled(t) },
    enumerable : !0,
    configurable : !0
  }),
         e.prototype
             .setEnabled =
             function(t) {
           return this._enabled != t &&
                      (this._enabled = t,
                       this._enabled ? this.onEnabled() : this.onDisabled()),
                  this
         },
  e.prototype.initialize = function() {},
  e.prototype.onAddedToEntity = function() {},
  e.prototype.onRemovedFromEntity = function() {},
  e.prototype.onEnabled = function() {}, e.prototype.onDisabled = function() {},
  e.prototype.onEntityTransformChanged = function(t) {},
  e.prototype.update = function() {}, e.prototype.debugRender = function() {},
  e.prototype.registerComponent = function() {
    this.entity.componentBits.set(ComponentTypeManager.getIndexFor(this), !1),
        this.entity.scene.entityProcessors.onComponentAdded(this.entity)
  }, e.prototype.deregisterComponent = function() {
    this.entity.componentBits.set(ComponentTypeManager.getIndexFor(this)),
        this.entity.scene.entityProcessors.onComponentRemoved(this.entity)
  }, e
}(egret.DisplayObjectContainer), Entity = function(t) {
  function e(n) {
    var i = t.call(this) || this;
    return i._position = Vector2.zero, i._updateOrder = 0, i._enabled = !0,
           i._tag = 0, i.name = n, i.components = new ComponentList(i),
           i.id = e._idGenerator++, i.componentBits = new BitSet, i
  }
  return __extends(e, t), Object.defineProperty(e.prototype, "isDestoryed", {
    get : function() { return this._isDestoryed },
    enumerable : !0,
    configurable : !0
  }),
         Object.defineProperty(e.prototype, "position", {
           get : function() { return this._position },
           set : function(t) { this._position = t },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(e.prototype, "scale", {
           get : function() { return new Vector2(this.scaleX, this.scaleY) },
           set : function(t) { this.scaleX = t.x, this.scaleY = t.y },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(e.prototype, "enabled", {
           get : function() { return this._enabled },
           set : function(t) { this.setEnabled(t) },
           enumerable : !0,
           configurable : !0
         }),
         e.prototype.setEnabled = function(
             t) { return this._enabled != t && (this._enabled = t), this },
         Object.defineProperty(e.prototype, "tag", {
           get : function() { return this._tag },
           set : function(t) { this.setTag(t) },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(e.prototype, "stage", {
           get : function() { return this.scene ? this.scene.stage : null },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(e.prototype, "updateOrder", {
           get : function() { return this._updateOrder },
           set : function(t) { this.setUpdateOrder(t) },
           enumerable : !0,
           configurable : !0
         }),
         e.prototype.roundPosition =
             function() { this.position = Vector2Ext.round(this.position) },
         e.prototype.setUpdateOrder = function(t) {
           if (this._updateOrder != t)
             return this._updateOrder = t, this.scene, this
         }, e.prototype.setTag = function(t) {
           return this._tag != t &&
                      (this.scene &&
                           this.scene.entities.removeFromTagList(this),
                       this._tag = t,
                       this.scene && this.scene.entities.addToTagList(this)),
                  this
         }, e.prototype.attachToScene = function(t) {
           this.scene = t, t.entities.add(this),
           this.components.registerAllComponents();
           for (var e = 0; e < this.numChildren; e++)
             this.getChildAt(e).entity.attachToScene(t)
         }, e.prototype.detachFromScene = function() {
           this.scene.entities.remove(this),
               this.components.deregisterAllComponents();
           for (var t = 0; t < this.numChildren; t++)
             this.getChildAt(t).entity.detachFromScene()
         }, e.prototype.addComponent = function(t) {
           return t.entity = this, this.components.add(t), this.addChild(t),
                  t.initialize(), t
         }, e.prototype.hasComponent = function(t) {
           return null != this.components.getComponent(t, !1)
         }, e.prototype.getOrCreateComponent = function(t) {
           var e = this.components.getComponent(t, !0);
           return e || (e = this.addComponent(t)), e
         }, e.prototype.getComponent = function(t) {
           return this.components.getComponent(t, !1)
         }, e.prototype.getComponents = function(t, e) {
           return this.components.getComponents(t, e)
         }, e.prototype.removeComponentForType = function(t) {
           var e = this.getComponent(t);
           return !!e && (this.removeComponent(e), !0)
         }, e.prototype.removeComponent = function(t) {
           this.components.remove(t)
         }, e.prototype.removeAllComponents = function() {
           for (var t = 0; t < this.components.count; t++)
             this.removeComponent(this.components.buffer[t])
         }, e.prototype.update = function() {
           this.components.update()
         }, e.prototype.onAddedToScene = function() {
         }, e.prototype.onRemovedFromScene = function() {
           this._isDestoryed && this.components.removeAllComponents()
         }, e.prototype.onTransformChanged = function(t) {
           this.components.onEntityTransformChanged(t)
         }, e.prototype.destroy = function() {
           this._isDestoryed = !0, this.scene.entities.remove(this),
           this.removeChildren();
           for (var t = this.numChildren - 1; t >= 0; t--) {
             this.getChildAt(t).entity.destroy()
           }
         }, e
}(egret.DisplayObjectContainer), Scene = function(t) {
  function e() {
    var e = t.call(this) || this;
    return e.enablePostProcessing = !0, e._renderers = [],
           e._postProcessors = [], e.entityProcessors = new EntityProcessorList,
           e.renderableComponents = new RenderableComponentList,
           e.entities = new EntityList(e), e.content = new ContentManager,
           e.width = SceneManager.stage.stageWidth,
           e.height = SceneManager.stage.stageHeight,
           e.addEventListener(egret.Event.ACTIVATE, e.onActive, e),
           e.addEventListener(egret.Event.DEACTIVATE, e.onDeactive, e), e
  }
  return __extends(e, t), e.prototype.createEntity = function(t) {
    var e = new Entity(t);
    return e.position = new Vector2(0, 0), this.addEntity(e)
  }, e.prototype.addEntity = function(t) {
    this.entities.add(t), t.scene = this, this.addChild(t);
    for (var e = 0; e < t.numChildren; e++)
      this.addEntity(t.getChildAt(e).entity);
    return t
  }, e.prototype.destroyAllEntities = function() {
    for (var t = 0; t < this.entities.count; t++)
      this.entities.buffer[t].destroy()
  }, e.prototype.findEntity = function(t) {
    return this.entities.findEntity(t)
  }, e.prototype.addEntityProcessor = function(t) {
    return t.scene = this, this.entityProcessors.add(t), t
  }, e.prototype.removeEntityProcessor = function(t) {
    this.entityProcessors.remove(t)
  }, e.prototype.getEntityProcessor = function() {
    return this.entityProcessors.getProcessor()
  }, e.prototype.addRenderer = function(t) {
    return this._renderers.push(t), this._renderers.sort(),
           t.onAddedToScene(this), t
  }, e.prototype.getRenderer = function(t) {
    for (var e = 0; e < this._renderers.length; e++)
      if (this._renderers[e] instanceof t)
        return this._renderers[e];
    return null
  }, e.prototype.removeRenderer = function(t) {
    this._renderers.remove(t), t.unload()
  }, e.prototype.begin = function() {
    SceneManager.sceneTransition ? SceneManager.stage.addChildAt(
                                       this, SceneManager.stage.numChildren - 1)
                                 : SceneManager.stage.addChild(this),
        0 == this._renderers.length &&
            (this.addRenderer(new DefaultRenderer),
             console.warn(
                 "场景开始时没有渲染器 自动添加DefaultRenderer以保证能够正常渲染")),
        this.camera =
            this.createEntity("camera").getOrCreateComponent(new Camera),
        Physics.reset(), this.entityProcessors && this.entityProcessors.begin(),
        this.camera.onSceneSizeChanged(this.stage.stageWidth,
                                       this.stage.stageHeight),
        this._didSceneBegin = !0, this.onStart()
  }, e.prototype.end = function() {
    this._didSceneBegin = !1,
    this.removeEventListener(egret.Event.DEACTIVATE, this.onDeactive, this),
    this.removeEventListener(egret.Event.ACTIVATE, this.onActive, this);
    for (var t = 0; t < this._renderers.length; t++)
      this._renderers[t].unload();
    for (t = 0; t < this._postProcessors.length; t++)
      this._postProcessors[t].unload();
    this.entities.removeAllEntities(), this.removeChildren(), Physics.clear(),
        this.camera = null, this.content.dispose(),
        this.entityProcessors && this.entityProcessors.end(), this.unload()
  }, e.prototype.onStart = function() {
    return __awaiter(
        this, void 0, void 0,
        function() { return __generator(this, function(t) { return [ 2 ] }) })
  }, e.prototype.onActive = function() {}, e.prototype.onDeactive = function() {
  }, e.prototype.unload = function() {}, e.prototype.update = function() {
    this.entities.updateLists(),
        this.entityProcessors && this.entityProcessors.update(),
        this.entities.update(),
        this.entityProcessors && this.entityProcessors.lateUpdate(),
        this.renderableComponents.updateList()
  }, e.prototype.postRender = function() {
    var t = 0;
    if (this.enablePostProcessing)
      for (var e = 0; e < this._postProcessors.length; e++)
        if (this._postProcessors[e].enable) {
          MathHelper.isEven(t);
          t++, this._postProcessors[e].process()
        }
  }, e.prototype.render = function() {
    for (var t = 0; t < this._renderers.length; t++)
      this._renderers[t].render(this)
  }, e.prototype.addPostProcessor = function(t) {
    return this._postProcessors.push(t), this._postProcessors.sort(),
           t.onAddedToScene(this),
           this._didSceneBegin &&
               t.onSceneBackBufferSizeChanged(this.stage.stageWidth,
                                              this.stage.stageHeight),
           t
  }, e
}(egret.DisplayObjectContainer), SceneManager = function() {
  function t(e) {
    e.addEventListener(egret.Event.ENTER_FRAME, t.update, this), t.stage = e,
                                                                 t.initialize(e)
  }
  return Object.defineProperty(t, "scene", {
    get : function() { return this._scene },
    set : function(t) {
      if (!t)
        throw new Error("场景不能为空");
      null == this._scene ? (this._scene = t, this._scene.begin())
                          : this._nextScene = t
    },
    enumerable : !0,
    configurable : !0
  }),
         t.initialize = function(t) { Input.initialize(t) },
         t.update = function() {
           if (Time.update(egret.getTimer()), t._scene) {
             for (var e = GlobalManager.globalManagers.length - 1; e >= 0; e--)
               GlobalManager.globalManagers[e].enabled &&
                   GlobalManager.globalManagers[e].update();
             if (t.sceneTransition &&
                         (!t.sceneTransition ||
                          t.sceneTransition.loadsNewScene &&
                              !t.sceneTransition.isNewSceneLoaded) ||
                     t._scene.update(),
                 t._nextScene) {
               t._scene.end();
               for (e = 0; e < t._scene.entities.buffer.length; e++) {
                 t._scene.entities.buffer[e].destroy()
               }
               t._scene = t._nextScene, t._nextScene = null, t._scene.begin()
             }
           }
           t.render()
         }, t.render = function() {
           this.sceneTransition
               ? (this.sceneTransition.preRender(),
                  this._scene && !this.sceneTransition.hasPreviousSceneRender
                      ? (this._scene.render(), this._scene.postRender(),
                         this.sceneTransition.onBeginTransition())
                      : this.sceneTransition &&
                            (this._scene &&
                                 this.sceneTransition.isNewSceneLoaded &&
                                 (this._scene.render(),
                                  this._scene.postRender()),
                             this.sceneTransition.render()))
               : this._scene && (this._scene.render(), this._scene.postRender())
         }, t.startSceneTransition = function(t) {
           if (!this.sceneTransition)
             return this.sceneTransition = t, t;
           console.warn("在前一个场景完成之前，不能开始一个新的场景转换。")
         }, t
}();
!function(t) {
  t[t.clean = 0] = "clean", t[t.positionDirty = 1] = "positionDirty",
              t[t.scaleDirty = 2] = "scaleDirty",
              t[t.rotationDirty = 3] = "rotationDirty"
}(DirtyType || (DirtyType = {})),
    function(t) {
      t[t.position = 0] = "position", t[t.scale = 1] = "scale",
                     t[t.rotation = 2] = "rotation"
    }(ComponentTransform || (ComponentTransform = {}));
var CameraStyle, Transform = function() {
  function t(t) {
    this._localRotation = 0, this._worldTransform = Matrix2D.identity,
    this._worldToLocalTransform = Matrix2D.identity,
    this._worldInverseTransform = Matrix2D.identity, this._rotation = 0,
    this.entity = t, this._scale = this._localScale = Vector2.one,
    this._children = []
  }
  return Object.defineProperty(t.prototype, "childCount", {
    get : function() { return this._children.length },
    enumerable : !0,
    configurable : !0
  }),
         t.prototype
             .getChild = function(t) { return this._children[t] },
  Object.defineProperty(t.prototype, "worldInverseTransform", {
    get : function() {
      return this.updateTransform(),
             this._worldInverseDirty &&
                 (this._worldInverseTransform = Matrix2D.invert(
                      this._worldTransform, this._worldInverseTransform),
                  this._worldInverseDirty = !1),
             this._worldInverseTransform
    },
    enumerable : !0,
    configurable : !0
  }),
  Object.defineProperty(t.prototype, "localToWorldTransform", {
    get : function() { return this.updateTransform(), this._worldTransform },
    enumerable : !0,
    configurable : !0
  }),
  Object.defineProperty(t.prototype, "worldToLocalTransform", {
    get : function() {
      return this._worldToLocalDirty &&
                 (this.parent ? (this.parent.updateTransform(),
                                 this._worldToLocalTransform = Matrix2D.invert(
                                     this.parent._worldTransform,
                                     this._worldToLocalTransform))
                              : this._worldInverseTransform = new Matrix2D,
                  this._worldToLocalDirty = !1),
             this._worldToLocalTransform
    },
    enumerable : !0,
    configurable : !0
  }),
  Object.defineProperty(t.prototype, "parent", {
    get : function() { return this._parent },
    set : function(t) { this.setParent(t) },
    enumerable : !0,
    configurable : !0
  }),
  t.prototype.setParent =
             function(t) {
    return this._parent == t
               ? this
               : (this._parent && this._parent._children.remove(this),
                  t && t._children.push(this), this._parent = t, this)
  },
  Object.defineProperty(t.prototype, "rotation", {
    get : function() { return this.updateTransform(), this._rotation },
    set : function(t) { this.setRotation(t) },
    enumerable : !0,
    configurable : !0
  }),
  Object.defineProperty(t.prototype, "localRotation", {
    get : function() { return this.updateTransform(), this._localRotation },
    set : function(t) { this.setLocalRotation(t) },
    enumerable : !0,
    configurable : !0
  }),
  Object.defineProperty(t.prototype, "position", {
    get : function() {
      return this.updateTransform(),
             this._positionDirty &&
                 (this.parent
                      ? (this.parent.updateTransform(),
                         this._position = Vector2Ext.transformR(
                             this._localPosition, this.parent._worldTransform))
                      : this._position = this._localPosition,
                  this._positionDirty = !1),
             this._position
    },
    set : function(t) { this.setPosition(t) },
    enumerable : !0,
    configurable : !0
  }),
  Object.defineProperty(t.prototype, "localPosition", {
    get : function() { return this.updateTransform(), this._localPosition },
    set : function(t) { this.setLocalPosition(t) },
    enumerable : !0,
    configurable : !0
  }),
  Object.defineProperty(t.prototype, "scale", {
    get : function() { return this.updateTransform(), this._scale },
    set : function(t) { this.setScale(t) },
    enumerable : !0,
    configurable : !0
  }),
  Object.defineProperty(t.prototype, "localScale", {
    get : function() { return this.updateTransform(), this._localScale },
    set : function(t) { this.setLocalScale(t) },
    enumerable : !0,
    configurable : !0
  }),
  Object.defineProperty(t.prototype, "rotationDegrees", {
    get : function() { return MathHelper.toDegrees(this._rotation) },
    set : function(t) { this.setRotation(MathHelper.toRadians(t)) },
    enumerable : !0,
    configurable : !0
  }),
  Object.defineProperty(t.prototype, "localRotationDegrees", {
    get : function() { return MathHelper.toDegrees(this._localRotation) },
    set : function(t) { this.localRotation = MathHelper.toRadians(t) },
    enumerable : !0,
    configurable : !0
  }),
  t.prototype.setLocalScale = function(t) {
    return this._localScale = t,
           this._localDirty = this._positionDirty = this._localScaleDirty = !0,
           this.setDirty(DirtyType.scaleDirty), this
  }, t.prototype.setScale = function(t) {
    return this._scale = t,
           this.parent ? this.localScale = Vector2.divide(t, this.parent._scale)
                       : this.localScale = t,
           this
  }, t.prototype.setLocalRotationDegrees = function(t) {
    return this.setLocalRotation(MathHelper.toRadians(t))
  }, t.prototype.setLocalRotation = function(t) {
    return this._localRotation = t,
           this._localDirty = this._positionDirty = this._localPositionDirty =
               this._localRotationDirty = this._localScaleDirty = !0,
           this.setDirty(DirtyType.rotationDirty), this
  }, t.prototype.setRotation = function(t) {
    return this._rotation = t,
           this.parent ? this.localRotation = this.parent.rotation + t
                       : this.localRotation = t,
           this
  }, t.prototype.setRotationDegrees = function(t) {
    return this.setRotation(MathHelper.toRadians(t))
  }, t.prototype.setLocalPosition = function(t) {
    return t == this._localPosition
               ? this
               : (this._localPosition = t,
                  this._localDirty = this._positionDirty =
                      this._localPositionDirty = this._localRotationDirty =
                          this._localScaleDirty = !0,
                  this.setDirty(DirtyType.positionDirty), this)
  }, t.prototype.setPosition = function(t) {
    return t == this._position
               ? this
               : (this._position = t,
                  this.parent ? this.localPosition = Vector2.transform(
                                    this._position, this._worldToLocalTransform)
                              : this.localPosition = t,
                  this._positionDirty = !1, this)
  }, t.prototype.setDirty = function(t) {
    if (0 == (this._hierachyDirty & t)) {
      switch (this._hierachyDirty |= t, t) {
      case DirtyType.positionDirty:
        this.entity.onTransformChanged(ComponentTransform.position);
        break;
      case DirtyType.rotationDirty:
        this.entity.onTransformChanged(ComponentTransform.rotation);
        break;
      case DirtyType.scaleDirty:
        this.entity.onTransformChanged(ComponentTransform.scale)
      }
      null == this._children && (this._children = []);
      for (var e = 0; e < this._children.length; e++)
        this._children[e].setDirty(t)
    }
  }, t.prototype.roundPosition = function() {
    this.position = this._position.round()
  }, t.prototype.updateTransform = function() {
    this._hierachyDirty != DirtyType.clean &&
        (this.parent && this.parent.updateTransform(),
         this._localDirty &&
             (this._localPositionDirty &&
                  (this._translationMatrix = Matrix2D.createTranslation(
                       this._localPosition.x, this._localPosition.y),
                   this._localPositionDirty = !1),
              this._localRotationDirty &&
                  (this._rotationMatrix =
                       Matrix2D.createRotation(this._localRotation),
                   this._localRotationDirty = !1),
              this._localScaleDirty &&
                  (this._scaleMatrix = Matrix2D.createScale(this._localScale.x,
                                                            this._localScale.y),
                   this._localScaleDirty = !1),
              this._localTransform =
                  Matrix2D.multiply(this._scaleMatrix, this._rotationMatrix),
              this._localTransform = Matrix2D.multiply(this._localTransform,
                                                       this._translationMatrix),
              this.parent || (this._worldTransform = this._localTransform,
                              this._rotation = this._localRotation,
                              this._scale = this._localScale,
                              this._worldInverseDirty = !0),
              this._localDirty = !1),
         this.parent &&
             (this._worldTransform = Matrix2D.multiply(
                  this._localTransform, this.parent._worldTransform),
              this._rotation = this._localRotation + this.parent._rotation,
              this._scale =
                  Vector2.multiply(this.parent._scale, this._localScale),
              this._worldInverseDirty = !0),
         this._worldToLocalDirty = !0, this._positionDirty = !0,
         this._hierachyDirty = DirtyType.clean)
  }, t
}(), Camera = function(t) {
  function e() {
    var e = t.call(this) || this;
    return e._origin = Vector2.zero, e._minimumZoom = .3, e._maximumZoom = 3,
           e.followLerp = .1, e.deadzone = new Rectangle,
           e.focusOffset = new Vector2, e.mapLockEnabled = !1,
           e.mapSize = new Vector2, e._worldSpaceDeadZone = new Rectangle,
           e._desiredPositionDelta = new Vector2,
           e.cameraStyle = CameraStyle.lockOn,
           e.width = SceneManager.stage.stageWidth,
           e.height = SceneManager.stage.stageHeight, e.setZoom(0), e
  }
  return __extends(e, t), Object.defineProperty(e.prototype, "zoom", {
    get : function() {
      return 0 == this._zoom
                 ? 1
                 : this._zoom < 1
                       ? MathHelper.map(this._zoom, this._minimumZoom, 1, -1, 0)
                       : MathHelper.map(this._zoom, 1, this._maximumZoom, 0, 1)
    },
    set : function(t) { this.setZoom(t) },
    enumerable : !0,
    configurable : !0
  }),
         Object.defineProperty(e.prototype, "minimumZoom", {
           get : function() { return this._minimumZoom },
           set : function(t) { this.setMinimumZoom(t) },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(e.prototype, "maximumZoom", {
           get : function() { return this._maximumZoom },
           set : function(t) { this.setMaximumZoom(t) },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(e.prototype, "origin", {
           get : function() { return this._origin },
           set : function(t) { this._origin != t && (this._origin = t) },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(e.prototype, "position", {
           get : function() { return this.entity.position },
           set : function(t) { this.entity.position = t },
           enumerable : !0,
           configurable : !0
         }),
         e.prototype
             .onSceneSizeChanged =
             function(t, e) {
           var n = this._origin;
           this.origin = new Vector2(t / 2, e / 2),
           this.entity.position = Vector2.add(this.entity.position,
                                              Vector2.subtract(this._origin, n))
         },
  e.prototype.setMinimumZoom = function(t) {
    return this._zoom < t && (this._zoom = this.minimumZoom),
           this._minimumZoom = t, this
  }, e.prototype.setMaximumZoom = function(t) {
    return this._zoom > t && (this._zoom = t), this._maximumZoom = t, this
  }, e.prototype.setZoom = function(t) {
    var e = MathHelper.clamp(t, -1, 1);
    return this._zoom =
               0 == e ? 1
                      : e < 0 ? MathHelper.map(e, -1, 0, this._minimumZoom, 1)
                              : MathHelper.map(e, 0, 1, 1, this._maximumZoom),
           SceneManager.scene.scaleX = this._zoom,
           SceneManager.scene.scaleY = this._zoom, this
  }, e.prototype.setRotation = function(t) {
    return SceneManager.scene.rotation = t, this
  }, e.prototype.setPosition = function(t) {
    return this.entity.position = t, this
  }, e.prototype.follow = function(t, e) {
    void 0 === e && (e = CameraStyle.cameraWindow), this.targetEntity = t,
                                                    this.cameraStyle = e;
    var n = new Rectangle(0, 0, SceneManager.stage.stageWidth,
                          SceneManager.stage.stageHeight);
    switch (this.cameraStyle) {
    case CameraStyle.cameraWindow:
      var i = n.width / 6, o = n.height / 3;
      this.deadzone =
          new Rectangle((n.width - i) / 2, (n.height - o) / 2, i, o);
      break;
    case CameraStyle.lockOn:
      this.deadzone = new Rectangle(n.width / 2, n.height / 2, 10, 10)
    }
  }, e.prototype.update = function() {
    var t = new Rectangle(0, 0, SceneManager.stage.stageWidth,
                          SceneManager.stage.stageHeight),
        e = Vector2.multiply(new Vector2(t.width, t.height), new Vector2(.5));
    this._worldSpaceDeadZone.x =
        this.position.x - e.x + this.deadzone.x + this.focusOffset.x,
    this._worldSpaceDeadZone.y =
        this.position.y - e.y + this.deadzone.y + this.focusOffset.y,
    this._worldSpaceDeadZone.width = this.deadzone.width,
    this._worldSpaceDeadZone.height = this.deadzone.height,
    this.targetEntity && this.updateFollow(),
    this.position = Vector2.lerp(
        this.position, Vector2.add(this.position, this._desiredPositionDelta),
        this.followLerp),
    this.entity.roundPosition(),
    this.mapLockEnabled && (this.position = this.clampToMapSize(this.position),
                            this.entity.roundPosition())
  }, e.prototype.clampToMapSize = function(t) {
    var e = new Rectangle(0, 0, SceneManager.stage.stageWidth,
                          SceneManager.stage.stageHeight),
        n = Vector2.multiply(new Vector2(e.width, e.height), new Vector2(.5)),
        i = new Vector2(this.mapSize.x - n.x, this.mapSize.y - n.y);
    return Vector2.clamp(t, n, i)
  }, e.prototype.updateFollow = function() {
    if (this._desiredPositionDelta.x = this._desiredPositionDelta.y = 0,
        this.cameraStyle == CameraStyle.lockOn) {
      var t = this.targetEntity.position.x, e = this.targetEntity.position.y;
      this._worldSpaceDeadZone.x > t
          ? this._desiredPositionDelta.x = t - this._worldSpaceDeadZone.x
          : this._worldSpaceDeadZone.x < t &&
                (this._desiredPositionDelta.x = t - this._worldSpaceDeadZone.x),
            this._worldSpaceDeadZone.y < e
                ? this._desiredPositionDelta.y = e - this._worldSpaceDeadZone.y
                : this._worldSpaceDeadZone.y > e &&
                      (this._desiredPositionDelta.y =
                           e - this._worldSpaceDeadZone.y)
    } else {
      if (!this._targetCollider &&
          (this._targetCollider = this.targetEntity.getComponent(Collider),
           !this._targetCollider))
        return;
      var n = this.targetEntity.getComponent(Collider).bounds;
      this._worldSpaceDeadZone.containsRect(n) ||
          (this._worldSpaceDeadZone.left > n.left
               ? this._desiredPositionDelta.x =
                     n.left - this._worldSpaceDeadZone.left
               : this._worldSpaceDeadZone.right < n.right &&
                     (this._desiredPositionDelta.x =
                          n.right - this._worldSpaceDeadZone.right),
           this._worldSpaceDeadZone.bottom < n.bottom
               ? this._desiredPositionDelta.y =
                     n.bottom - this._worldSpaceDeadZone.bottom
               : this._worldSpaceDeadZone.top > n.top &&
                     (this._desiredPositionDelta.y =
                          n.top - this._worldSpaceDeadZone.top))
    }
  }, e
}(Component);
!function(
    t) { t[t.lockOn = 0] = "lockOn", t[t.cameraWindow = 1] = "cameraWindow" }(
    CameraStyle || (CameraStyle = {}));
var PointSectors, ComponentPool = function() {
  function t(t) { this._type = t, this._cache = [] }
  return t.prototype.obtain = function() {
    try {
      return this._cache.length > 0 ? this._cache.shift() : new this._type
    } catch (t) {
      throw new Error(this._type + t)
    }
  }, t.prototype.free = function(t) { t.reset(), this._cache.push(t) }, t
}(), Mesh = function(t) {
  function e() { return null !== t && t.apply(this, arguments) || this }
  return __extends(e, t),
         e.prototype.initialize = function() {},
         e.prototype.setVertPosition = function(t) {
           (!this._verts || this._verts.length != t.length) &&
               (this._verts = new Array(t.length));
           for (var e = 0; e < this._verts.length; e++)
             this._verts[e] = new VertexPosition(t[e]);
           return this
         }, e.prototype.setTriangles = function(t) {
           return this._primitiveCount = t.length / 3, this._triangles = t, this
         }, e.prototype.recalculateBounds = function() {
           this._topLeftVertPosition =
               new Vector2(Number.MAX_VALUE, Number.MAX_VALUE);
           for (var t = new Vector2(Number.MIN_VALUE, Number.MIN_VALUE), e = 0;
                e < this._verts.length; e++)
             this._topLeftVertPosition.x = Math.min(this._topLeftVertPosition.x,
                                                    this._verts[e].position.x),
             this._topLeftVertPosition.y = Math.min(this._topLeftVertPosition.y,
                                                    this._verts[e].position.y),
             t.x = Math.max(t.x, this._verts[e].position.x),
             t.y = Math.max(t.y, this._verts[e].position.y);
           return this._width = t.x - this._topLeftVertPosition.x,
                  this._height = t.y - this._topLeftVertPosition.y, this
         }, e.prototype.render = function() {}, e
}(Component), VertexPosition = function() {
  return function(t) { this.position = t }
}(), PolygonMesh = function(t) {
  function e(e, n) {
    void 0 === n && (n = !0);
    var i = t.call(this) || this, o = new Triangulator;
    return o.triangulate(e, n), i.setVertPosition(e),
           i.setTriangles(o.triangleIndices), i.recalculateBounds(), i
  }
  return __extends(e, t), e
}(Mesh), PooledComponent = function(t) {
  function e() { return null !== t && t.apply(this, arguments) || this }
  return __extends(e, t), e
}(Component), RenderableComponent = function(t) {
  function e() {
    var e = null !== t && t.apply(this, arguments) || this;
    return e._areBoundsDirty = !0, e._bounds = new Rectangle,
           e._localOffset = Vector2.zero, e.color = 0, e
  }
  return __extends(e, t), Object.defineProperty(e.prototype, "width", {
    get : function() { return this.getWidth() },
    enumerable : !0,
    configurable : !0
  }),
         Object.defineProperty(e.prototype, "height", {
           get : function() { return this.getHeight() },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(e.prototype, "isVisible", {
           get : function() { return this._isVisible },
           set : function(t) {
             this._isVisible = t,
             this._isVisible ? this.onBecameVisible() : this.onBecameInvisible()
           },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(e.prototype, "bounds", {
           get : function() {
             return new Rectangle(this.getBounds().x, this.getBounds().y,
                                  this.getBounds().width,
                                  this.getBounds().height)
           },
           enumerable : !0,
           configurable : !0
         }),
         e.prototype.getWidth = function() { return this.bounds.width },
         e.prototype.getHeight = function() { return this.bounds.height },
         e.prototype.onBecameVisible = function() {},
         e.prototype.onBecameInvisible = function() {},
         e.prototype.isVisibleFromCamera =
             function(t) {
           return this.isVisible = t.getBounds().intersects(this.getBounds()),
                  this.isVisible
         },
         e.prototype.onEntityTransformChanged = function(
             t) { this._areBoundsDirty = !0 },
         e
}(PooledComponent), ScreenSpaceCamera = function(t) {
  function e() { return null !== t && t.apply(this, arguments) || this }
  return __extends(e, t), e.prototype.updateMatrixes = function() {}, e
}(Camera), Sprite = function() {
  return function(t, e, n) {
    void 0 === e && (e = new Rectangle(0, 0, t.textureWidth, t.textureHeight)),
        void 0 === n && (n = e.getHalfSize()),
        this.uvs = new Rectangle, this.texture2D = t, this.sourceRect = e,
        this.center = new Vector2(.5 * e.width, .5 * e.height), this.origin = n;
    var i = 1 / t.textureWidth, o = 1 / t.textureHeight;
    this.uvs.x = e.x * i, this.uvs.y = e.y * o, this.uvs.width = e.width * i,
    this.uvs.height = e.height * o
  }
}(), SpriteRenderer = function(t) {
  function e() { return null !== t && t.apply(this, arguments) || this }
  return __extends(e, t), Object.defineProperty(e.prototype, "origin", {
    get : function() { return this._origin },
    set : function(t) { this.setOrigin(t) },
    enumerable : !0,
    configurable : !0
  }),
         e.prototype.setOrigin = function(
             t) { return this._origin != t && (this._origin = t), this },
         e.prototype.setSprite = function(t) {
           return this.removeChildren(),
                  this._sprite = t,
                  this._sprite && (this._origin = this._sprite.origin),
                  this._bitmap = new egret.Bitmap(t.texture2D),
                  this.addChild(this._bitmap), this
         }, e.prototype.setColor = function(t) {
           var e =
               [ 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0 ];
           e[0] = Math.floor(t / 256 / 256) / 255,
           e[6] = Math.floor(t / 256 % 256) / 255, e[12] = t % 256 / 255;
           var n = new egret.ColorMatrixFilter(e);
           return this.filters = [ n ], this
         }, e.prototype.isVisibleFromCamera = function(t) {
           return this.isVisible = new Rectangle(0, 0, this.stage.stageWidth,
                                                 this.stage.stageHeight)
                                       .intersects(this.bounds),
                  this.visible = this.isVisible, this.isVisible
         }, e.prototype.render = function(t) {
           this.x = this.entity.position.x - this.origin.x - t.position.x +
                    t.origin.x,
           this.y = this.entity.position.y - this.origin.y - t.position.y +
                    t.origin.y
         }, e.prototype.onRemovedFromEntity = function() {
           this.parent && this.parent.removeChild(this)
         }, e.prototype.reset = function() {}, e
}(RenderableComponent), Mover = function(t) {
  function e() { return null !== t && t.apply(this, arguments) || this }
  return __extends(e, t), e.prototype.onAddedToEntity = function() {
    this._triggerHelper = new ColliderTriggerHelper(this.entity)
  }, e.prototype.calculateMovement = function(t) {
    var e = new CollisionResult;
    if (!this.entity.getComponent(Collider) || !this._triggerHelper)
      return null;
    for (var n = this.entity.getComponents(Collider), i = 0; i < n.length;
         i++) {
      var o = n[i];
      if (!o.isTrigger) {
        var r = o.bounds;
        r.x += t.x, r.y += t.y;
        for (var s = Physics.boxcastBroadphaseExcludingSelf(
                     o, r, o.collidesWithLayers),
                 a = 0;
             a < s.length; a++) {
          var h = s[a];
          if (!h.isTrigger) {
            var c = o.collidesWith(h, t);
            c && (t = Vector2.subtract(t, c.minimumTranslationVector),
                  c.collider && (e = c))
          }
        }
      }
    }
    return ListPool.free(n), e
  }, e.prototype.applyMovement = function(t) {
    this.entity.position = Vector2.add(this.entity.position, t),
    this._triggerHelper && this._triggerHelper.update()
  }, e.prototype.move = function(t) {
    var e = this.calculateMovement(t);
    return this.applyMovement(t), e
  }, e
}(Component), Collider = function(t) {
  function e() {
    var e = null !== t && t.apply(this, arguments) || this;
    return e.physicsLayer = 1,
           e.shouldColliderScaleAndRotationWithTransform = !0,
           e.collidesWithLayers = Physics.allLayers, e._isPositionDirty = !0,
           e._isRotationDirty = !0, e._localOffset = new Vector2(0, 0), e
  }
  return __extends(e, t), Object.defineProperty(e.prototype, "bounds", {
    get : function() {
      return (this._isPositionDirty || this._isRotationDirty) &&
                 (this.shape.recalculateBounds(this),
                  this._isPositionDirty = this._isRotationDirty = !1),
             this.shape.bounds
    },
    enumerable : !0,
    configurable : !0
  }),
         Object.defineProperty(e.prototype, "localOffset", {
           get : function() { return this._localOffset },
           set : function(t) { this.setLocalOffset(t) },
           enumerable : !0,
           configurable : !0
         }),
         e.prototype
             .setLocalOffset =
             function(t) {
           this._localOffset != t &&
               (this.unregisterColliderWithPhysicsSystem(),
                this._localOffset = t,
                this._localOffsetLength = this._localOffset.length(),
                this._isPositionDirty = !0,
                this.registerColliderWithPhysicsSystem())
         },
  e.prototype.registerColliderWithPhysicsSystem = function() {
    this._isParentEntityAddedToScene && !this._isColliderRegistered &&
        (Physics.addCollider(this), this._isColliderRegistered = !0)
  }, e.prototype.unregisterColliderWithPhysicsSystem = function() {
    this._isParentEntityAddedToScene && this._isColliderRegistered &&
        Physics.removeCollider(this),
        this._isColliderRegistered = !1
  }, e.prototype.overlaps = function(t) {
    return this.shape.overlaps(t.shape)
  }, e.prototype.collidesWith = function(t, e) {
    var n = this.shape.position;
    this.shape.position = Vector2.add(this.shape.position, e);
    var i = this.shape.collidesWithShape(t.shape);
    return i && (i.collider = t), this.shape.position = n, i
  }, e.prototype.onAddedToEntity = function() {
    if (this._colliderRequiresAutoSizing) {
      this instanceof BoxCollider ||
          console.error(
              "Only box and circle colliders can be created automatically");
      var t = this.entity.getComponent(RenderableComponent);
      if (t) {
        var e = t.bounds, n = e.width / this.entity.scale.x,
            i = e.height / this.entity.scale.y;
        if (this instanceof BoxCollider) {
          this.width = n, this.height = i,
          this.localOffset = Vector2.subtract(e.center, this.entity.position)
        }
      }
    }
    this._isParentEntityAddedToScene = !0,
    this.registerColliderWithPhysicsSystem()
  }, e.prototype.onRemovedFromEntity = function() {
    this.unregisterColliderWithPhysicsSystem(),
        this._isParentEntityAddedToScene = !1
  }, e.prototype.onEntityTransformChanged = function(t) {
    switch (t) {
    case ComponentTransform.position:
    case ComponentTransform.scale:
      this._isPositionDirty = !0;
      break;
    case ComponentTransform.rotation:
      this._isRotationDirty = !0
    }
    this._isColliderRegistered && Physics.updateCollider(this)
  }, e.prototype.onEnabled = function() {
    this.registerColliderWithPhysicsSystem(),
        this._isPositionDirty = this._isRotationDirty = !0
  }, e.prototype.onDisabled = function() {
    this.unregisterColliderWithPhysicsSystem()
  }, e
}(Component), BoxCollider = function(t) {
  function e() {
    var e = t.call(this) || this;
    return e.shape = new Box(1, 1), e._colliderRequiresAutoSizing = !0, e
  }
  return __extends(e, t), Object.defineProperty(e.prototype, "width", {
    get : function() { return this.shape.width },
    set : function(t) { this.setWidth(t) },
    enumerable : !0,
    configurable : !0
  }),
         e.prototype.setWidth =
             function(t) {
           this._colliderRequiresAutoSizing = !1;
           var e = this.shape;
           return t != e.width &&
                      (e.updateBox(t, e.height), this._isPositionDirty = !0,
                       this.entity && this._isParentEntityAddedToScene &&
                           Physics.updateCollider(this)),
                  this
         },
         Object.defineProperty(e.prototype, "height", {
           get : function() { return this.shape.height },
           set : function(t) { this.setHeight(t) },
           enumerable : !0,
           configurable : !0
         }),
         e.prototype.setHeight = function(t) {
           this._colliderRequiresAutoSizing = !1;
           var e = this.shape;
           t != e.height &&
               (e.updateBox(e.width, t), this._isPositionDirty = !0,
                this.entity && this._isParentEntityAddedToScene &&
                    Physics.updateCollider(this))
         }, e.prototype.setSize = function(t, e) {
           this._colliderRequiresAutoSizing = !1;
           var n = this.shape;
           return t == n.width && e == n.height ||
                      (n.updateBox(t, e), this._isPositionDirty = !0,
                       this.entity && this._isParentEntityAddedToScene &&
                           Physics.updateCollider(this)),
                  this
         }, e
}(Collider), EntitySystem = function() {
  function t(t) { this._entities = [], this._matcher = t || Matcher.empty() }
  return Object.defineProperty(t.prototype, "matcher", {
    get : function() { return this._matcher },
    enumerable : !0,
    configurable : !0
  }),
         Object.defineProperty(t.prototype, "scene", {
           get : function() { return this._scene },
           set : function(t) { this._scene = t, this._entities = [] },
           enumerable : !0,
           configurable : !0
         }),
         t.prototype.initialize = function() {},
         t.prototype.onChanged =
             function(t) {
           var e = this._entities.contains(t), n = this._matcher.IsIntersted(t);
           n && !e ? this.add(t) : !n && e && this.remove(t)
         },
         t.prototype.add = function(
             t) { this._entities.push(t), this.onAdded(t) },
         t.prototype.onAdded = function(t) {},
         t.prototype.remove = function(
             t) { this._entities.remove(t), this.onRemoved(t) },
         t.prototype.onRemoved = function(t) {},
         t.prototype.update =
             function() { this.begin(), this.process(this._entities) },
         t.prototype.lateUpdate =
             function() { this.lateProcess(this._entities), this.end() },
         t.prototype.begin = function() {},
         t.prototype.process = function(t) {},
         t.prototype.lateProcess = function(t) {},
         t.prototype.end = function() {}, t
}(), EntityProcessingSystem = function(t) {
  function e(e) { return t.call(this, e) || this }
  return __extends(e, t),
         e.prototype.lateProcessEntity = function(t) {},
         e.prototype.process = function(t) {
           var e = this;
           t.forEach(function(t) { return e.processEntity(t) })
         }, e.prototype.lateProcess = function(t) {
           var e = this;
           t.forEach(function(t) { return e.lateProcessEntity(t) })
         }, e
}(EntitySystem), PassiveSystem = function(t) {
  function e() { return null !== t && t.apply(this, arguments) || this }
  return __extends(e, t),
         e.prototype.onChanged = function(t) {},
         e.prototype.process = function(t) { this.begin(), this.end() }, e
}(EntitySystem), ProcessingSystem = function(t) {
  function e() { return null !== t && t.apply(this, arguments) || this }
  return __extends(e, t),
         e.prototype.onChanged = function(t) {},
         e.prototype.process = function(
             t) { this.begin(), this.processSystem(), this.end() },
         e
}(EntitySystem), BitSet = function() {
  function t(e) {
    void 0 === e && (e = 64);
    var n = e >> 6;
    0 != (e & t.LONG_MASK) && n++, this._bits = new Array(n)
  }
  return t.prototype.and = function(t) {
    for (var e, n = Math.min(this._bits.length, t._bits.length), i = 0; i < n;
         ++i)
      this._bits[i] &= t._bits[i];
    for (; e < this._bits.length;)
      this._bits[e++] = 0
  }, t.prototype.andNot = function(t) {
    for (var e = Math.min(this._bits.length, t._bits.length); --e >= 0;)
      this._bits[e] &= ~t._bits[e]
  }, t.prototype.cardinality = function() {
    for (var t = 0, e = this._bits.length - 1; e >= 0; e--) {
      var n = this._bits[e];
      if (0 != n)
        if (-1 != n) {
          var i = ((n = ((n = (n >> 1 & 0x5555555555555400) +
                              (0x5555555555555400 & n)) >>
                             2 &
                         0x3333333333333400) +
                        (0x3333333333333400 & n)) >>
                   32) +
                  n;
          t += ((i = ((i = (i >> 4 & 252645135) + (252645135 & i)) >> 8 &
                      16711935) +
                     (16711935 & i)) >>
                    16 &
                65535) +
               (65535 & i)
        } else
          t += 64
    }
    return t
  }, t.prototype.clear = function(t) {
    if (null != t) {
      var e = t >> 6;
      this.ensure(e), this._bits[e] &= ~(1 << t)
    } else
      for (var n = 0; n < this._bits.length; n++)
        this._bits[n] = 0
  }, t.prototype.ensure = function(t) {
    if (t >= this._bits.length) {
      var e = new Number[t + 1];
      e = this._bits.copyWithin(0, 0, this._bits.length), this._bits = e
    }
  }, t.prototype.get = function(t) {
    var e = t >> 6;
    return !(e >= this._bits.length) && 0 != (this._bits[e] & 1 << t)
  }, t.prototype.intersects = function(t) {
    for (var e = Math.min(this._bits.length, t._bits.length); --e >= 0;)
      if (0 != (this._bits[e] & t._bits[e]))
        return !0;
    return !1
  }, t.prototype.isEmpty = function() {
    for (var t = this._bits.length - 1; t >= 0; t--)
      if (this._bits[t])
        return !1;
    return !0
  }, t.prototype.nextSetBit = function(t) {
    for (var e = t >> 6, n = 1 << t; e < this._bits.length;) {
      var i = this._bits[e];
      do {
        if (0 != (i & n))
          return t;
        n <<= 1, t++
      } while (0 != n);
      n = 1, e++
    }
    return -1
  }, t.prototype.set = function(t, e) {
    if (void 0 === e && (e = !0), e) {
      var n = t >> 6;
      this.ensure(n), this._bits[n] |= 1 << t
    } else
      this.clear(t)
  }, t.LONG_MASK = 63, t
}(), ComponentList = function() {
  function t(t) {
    this._components = [], this._componentsToAdd = [],
    this._componentsToRemove = [], this._tempBufferList = [], this._entity = t
  }
  return Object.defineProperty(t.prototype, "count", {
    get : function() { return this._components.length },
    enumerable : !0,
    configurable : !0
  }),
         Object.defineProperty(t.prototype, "buffer", {
           get : function() { return this._components },
           enumerable : !0,
           configurable : !0
         }),
         t.prototype
             .add = function(t) { this._componentsToAdd.push(t) },
  t.prototype.remove = function(t) {
    this._componentsToAdd.contains(t) ? this._componentsToAdd.remove(t)
                                      : this._componentsToRemove.push(t)
  }, t.prototype.removeAllComponents = function() {
    for (var t = 0; t < this._components.length; t++)
      this.handleRemove(this._components[t]);
    this._components.length = 0, this._componentsToAdd.length = 0,
    this._componentsToRemove.length = 0
  }, t.prototype.deregisterAllComponents = function() {
    for (var t = 0; t < this._components.length; t++) {
      var e = this._components[t];
      e instanceof RenderableComponent &&
          this._entity.scene.renderableComponents.remove(e),
          this._entity.componentBits.set(ComponentTypeManager.getIndexFor(e),
                                         !1),
          this._entity.scene.entityProcessors.onComponentRemoved(this._entity)
    }
  }, t.prototype.registerAllComponents = function() {
    for (var t = 0; t < this._components.length; t++) {
      var e = this._components[t];
      e instanceof RenderableComponent &&
          this._entity.scene.renderableComponents.add(e),
          this._entity.componentBits.set(ComponentTypeManager.getIndexFor(e)),
          this._entity.scene.entityProcessors.onComponentAdded(this._entity)
    }
  }, t.prototype.updateLists = function() {
    if (this._componentsToRemove.length > 0) {
      for (var t = 0; t < this._componentsToRemove.length; t++)
        this.handleRemove(this._componentsToRemove[t]),
            this._components.remove(this._componentsToRemove[t]);
      this._componentsToRemove.length = 0
    }
    if (this._componentsToAdd.length > 0) {
      t = 0;
      for (var e = this._componentsToAdd.length; t < e; t++) {
        (n = this._componentsToAdd[t]) instanceof RenderableComponent &&
            this._entity.scene.renderableComponents.add(n),
            this._entity.componentBits.set(ComponentTypeManager.getIndexFor(n)),
            this._entity.scene.entityProcessors.onComponentAdded(this._entity),
            this._components.push(n), this._tempBufferList.push(n)
      }
      this._componentsToAdd.length = 0;
      for (t = 0; t < this._tempBufferList.length; t++) {
        var n;
        (n = this._tempBufferList[t]).onAddedToEntity(),
            n.enabled && n.onEnabled()
      }
      this._tempBufferList.length = 0
    }
  }, t.prototype.handleRemove = function(t) {
    t instanceof RenderableComponent &&
        this._entity.scene.renderableComponents.remove(t),
        this._entity.componentBits.set(ComponentTypeManager.getIndexFor(t), !1),
        this._entity.scene.entityProcessors.onComponentRemoved(this._entity),
        t.onRemovedFromEntity(), t.entity = null
  }, t.prototype.getComponent = function(t, e) {
    for (var n = 0; n < this._components.length; n++) {
      if ((i = this._components[n]) instanceof t)
        return i
    }
    if (!e)
      for (n = 0; n < this._componentsToAdd.length; n++) {
        var i;
        if ((i = this._componentsToAdd[n]) instanceof t)
          return i
      }
    return null
  }, t.prototype.getComponents = function(t, e) {
    e || (e = []);
    for (var n = 0; n < this._components.length; n++) {
      var i = this._components[n];
      "string" == typeof t ? egret.is(i, t) && e.push(i)
                           : i instanceof t && e.push(i)
    }
    for (n = 0; n < this._componentsToAdd.length; n++) {
      i = this._componentsToAdd[n];
      "string" == typeof t ? egret.is(i, t) && e.push(i)
                           : i instanceof t && e.push(i)
    }
    return e
  }, t.prototype.update = function() {
    this.updateLists();
    for (var t = 0; t < this._components.length; t++) {
      var e = this._components[t];
      !e.enabled ||
          1 != e.updateInterval && Time.frameCount % e.updateInterval != 0 ||
          e.update()
    }
  }, t.prototype.onEntityTransformChanged = function(t) {
    for (var e = 0; e < this._components.length; e++)
      this._components[e].enabled &&
          this._components[e].onEntityTransformChanged(t);
    for (e = 0; e < this._componentsToAdd.length; e++)
      this._componentsToAdd[e].enabled &&
          this._componentsToAdd[e].onEntityTransformChanged(t)
  }, t
}(), ComponentTypeManager = function() {
  function t() {}
  return t.add = function(t) {
    this._componentTypesMask.has(t) ||
        (this._componentTypesMask[t] = this._componentTypesMask.size)
  }, t.getIndexFor = function(t) {
    var e = -1;
    return this._componentTypesMask.has(t) ||
               (this.add(t), e = this._componentTypesMask.get(t)),
           e
  }, t._componentTypesMask = new Map, t
}(), EntityList = function() {
  function t(t) {
    this._entitiesToRemove = [], this._entitiesToAdded = [],
    this._tempEntityList = [], this._entities = [], this._entityDict = new Map,
    this._unsortedTags = [], this.scene = t
  }
  return Object.defineProperty(t.prototype, "count", {
    get : function() { return this._entities.length },
    enumerable : !0,
    configurable : !0
  }),
         Object.defineProperty(t.prototype, "buffer", {
           get : function() { return this._entities },
           enumerable : !0,
           configurable : !0
         }),
         t.prototype.add = function(t) {
           -1 == this._entitiesToAdded.indexOf(t) &&
               this._entitiesToAdded.push(t)
         }, t.prototype.remove = function(t) {
           this._entitiesToAdded.contains(t)
               ? this._entitiesToAdded.remove(t)
               : this._entitiesToRemove.contains(t) ||
                     this._entitiesToRemove.push(t)
         }, t.prototype.findEntity = function(t) {
           for (var e = 0; e < this._entities.length; e++)
             if (this._entities[e].name == t)
               return this._entities[e];
           return this._entitiesToAdded.firstOrDefault(function(
               e) { return e.name == t })
         }, t.prototype.getTagList = function(t) {
           var e = this._entityDict.get(t);
           return e || (e = [], this._entityDict.set(t, e)),
                  this._entityDict.get(t)
         }, t.prototype.addToTagList = function(t) {
           var e = this.getTagList(t.tag);
           e.contains(t) || (e.push(t), this._unsortedTags.push(t.tag))
         }, t.prototype.removeFromTagList = function(t) {
           var e = this._entityDict.get(t.tag);
           e && e.remove(t)
         }, t.prototype.update = function() {
           for (var t = 0; t < this._entities.length; t++) {
             var e = this._entities[t];
             e.enabled && e.update()
           }
         }, t.prototype.removeAllEntities = function() {
           this._entitiesToAdded.length = 0, this.updateLists();
           for (var t = 0; t < this._entities.length; t++)
             this._entities[t]._isDestoryed = !0,
             this._entities[t].onRemovedFromScene(),
             this._entities[t].scene = null;
           this._entities.length = 0, this._entityDict.clear()
         }, t.prototype.updateLists = function() {
           var t = this;
           if (this._entitiesToRemove.length > 0) {
             var e = this._entitiesToRemove;
             this._entitiesToRemove = this._tempEntityList,
             this._tempEntityList = e,
             this._tempEntityList.forEach(function(e) {
               t._entities.remove(e),
                   e.scene = null, t.scene.entityProcessors.onEntityRemoved(e)
             }),
             this._tempEntityList.length = 0
           }
           if (this._entitiesToAdded.length > 0) {
             e = this._entitiesToAdded;
             this._entitiesToAdded = this._tempEntityList,
             this._tempEntityList = e,
             this._tempEntityList.forEach(function(e) {
               t._entities.contains(e) ||
                   (t._entities.push(e), e.scene = t.scene,
                    t.scene.entityProcessors.onEntityAdded(e))
             }),
             this._tempEntityList.forEach(function(
                 t) { return t.onAddedToScene() }),
             this._tempEntityList.length = 0
           }
           this._unsortedTags.length > 0 &&
               (this._unsortedTags.forEach(function(
                    e) { t._entityDict.get(e).sort() }),
                this._unsortedTags.length = 0)
         }, t
}(), EntityProcessorList = function() {
  function t() { this._processors = [] }
  return t.prototype
             .add = function(t) { this._processors.push(t) },
  t.prototype.remove = function(t) { this._processors.remove(t) },
  t.prototype.onComponentAdded = function(t) { this.notifyEntityChanged(t) },
  t.prototype.onComponentRemoved = function(t) { this.notifyEntityChanged(t) },
  t.prototype.onEntityAdded = function(t) { this.notifyEntityChanged(t) },
  t.prototype.onEntityRemoved = function(t) { this.removeFromProcessors(t) },
  t.prototype.notifyEntityChanged = function(t) {
    for (var e = 0; e < this._processors.length; e++)
      this._processors[e].onChanged(t)
  }, t.prototype.removeFromProcessors = function(t) {
    for (var e = 0; e < this._processors.length; e++)
      this._processors[e].remove(t)
  }, t.prototype.begin = function() {}, t.prototype.update = function() {
    for (var t = 0; t < this._processors.length; t++)
      this._processors[t].update()
  }, t.prototype.lateUpdate = function() {
    for (var t = 0; t < this._processors.length; t++)
      this._processors[t].lateUpdate()
  }, t.prototype.end = function() {}, t.prototype.getProcessor = function() {
    for (var t = 0; t < this._processors.length; t++) {
      var e = this._processors[t];
      if (e instanceof EntitySystem)
        return e
    }
    return null
  }, t
}(), Matcher = function() {
  function t() {
    this.allSet = new BitSet, this.exclusionSet = new BitSet,
    this.oneSet = new BitSet
  }
  return t.empty = function() { return new t },
         t.prototype.getAllSet = function() { return this.allSet },
         t.prototype.getExclusionSet = function() { return this.exclusionSet },
         t.prototype.getOneSet = function() { return this.oneSet },
         t.prototype.IsIntersted = function(t) {
           if (!this.allSet.isEmpty())
             for (var e = this.allSet.nextSetBit(0); e >= 0;
                  e = this.allSet.nextSetBit(e + 1))
               if (!t.componentBits.get(e))
                 return !1;
           return !(!this.exclusionSet.isEmpty() &&
                    this.exclusionSet.intersects(t.componentBits)) &&
                  !(!this.oneSet.isEmpty() &&
                    !this.oneSet.intersects(t.componentBits))
         }, t.prototype.all = function() {
           for (var t = this, e = [], n = 0; n < arguments.length; n++)
             e[n] = arguments[n];
           return e.forEach(function(
                      e) { t.allSet.set(ComponentTypeManager.getIndexFor(e)) }),
                  this
         }, t.prototype.exclude = function() {
           for (var t = this, e = [], n = 0; n < arguments.length; n++)
             e[n] = arguments[n];
           return e.forEach(function(e) {
             t.exclusionSet.set(ComponentTypeManager.getIndexFor(e))
           }),
                  this
         }, t.prototype.one = function() {
           for (var t = this, e = [], n = 0; n < arguments.length; n++)
             e[n] = arguments[n];
           return e.forEach(function(
                      e) { t.oneSet.set(ComponentTypeManager.getIndexFor(e)) }),
                  this
         }, t
}(), RenderableComponentList = function() {
  function t() { this._components = [] }
  return Object.defineProperty(t.prototype, "count", {
    get : function() { return this._components.length },
    enumerable : !0,
    configurable : !0
  }),
         Object.defineProperty(t.prototype, "buffer", {
           get : function() { return this._components },
           enumerable : !0,
           configurable : !0
         }),
         t.prototype.add = function(t) { this._components.push(t) },
         t.prototype.remove = function(t) { this._components.remove(t) },
         t.prototype.updateList = function() {}, t
}(), Time = function() {
  function t() {}
  return t.update = function(t) {
    var e = (t - this._lastTime) / 1e3;
    this.deltaTime = e * this.timeScale, this.unscaledDeltaTime = e,
    this.frameCount++, this._lastTime = t
  }, t.deltaTime = 0, t.timeScale = 1, t.frameCount = 0, t._lastTime = 0, t
}(), GraphicsCapabilities = function() {
  function t() {}
  return t.prototype.initialize = function(t) { this.platformInitialize(t) },
         t.prototype.platformInitialize = function(t) {
           var e = (new egret.sys.RenderBuffer).context.getInstance();
           this.supportsNonPowerOfTwo = !1,
           this.supportsTextureFilterAnisotropic =
               null != e.getExtension("EXT_texture_filter_anisotropic"),
           this.supportsDepth24 = !0, this.supportsPackedDepthStencil = !0,
           this.supportsDepthNonLinear = !1, this.supportsTextureMaxLevel = !0,
           this.supportsS3tc =
               null != e.getExtension("WEBGL_compressed_texture_s3tc") ||
               null != e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
           this.supportsDxt1 = this.supportsS3tc, this.supportsPvrtc = !1,
           this.supportsAtitc =
               null != e.getExtension("WEBGL_compressed_texture_astc"),
           this.supportsFramebufferObjectARB = !1
         }, t
}(), GraphicsDevice = function() {
  return function() {
    this.graphicsCapabilities = new GraphicsCapabilities,
    this.graphicsCapabilities.initialize(this)
  }
}(), Viewport = function() {
  function t(t, e, n, i) {
    this._x = t, this._y = e, this._width = n, this._height = i,
    this._minDepth = 0, this._maxDepth = 1
  }
  return Object.defineProperty(t.prototype, "aspectRatio", {
    get : function() {
      return 0 != this._height && 0 != this._width ? this._width / this._height
                                                   : 0
    },
    enumerable : !0,
    configurable : !0
  }),
         Object.defineProperty(t.prototype, "bounds", {
           get : function() {
             return new Rectangle(this._x, this._y, this._width, this._height)
           },
           set : function(t) {
             this._x = t.x, this._y = t.y, this._width = t.width,
             this._height = t.height
           },
           enumerable : !0,
           configurable : !0
         }),
         t
}(), GraphicsResource = function() {
  return function() {}
}(), GaussianBlurEffect = function(t) {
  function e() {
    return t.call(this, PostProcessor.default_vert, e.blur_frag, {
      screenWidth : SceneManager.stage.stageWidth,
      screenHeight : SceneManager.stage.stageHeight
    }) || this
  }
  return __extends(e, t),
         e.blur_frag =
             "precision mediump float;\nuniform sampler2D uSampler;\nuniform float screenWidth;\nuniform float screenHeight;\nfloat normpdf(in float x, in float sigma)\n{\nreturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\nvoid main()\n{\nvec3 c = texture2D(uSampler, gl_FragCoord.xy / vec2(screenWidth, screenHeight).xy).rgb;\nconst int mSize = 11;\nconst int kSize = (mSize - 1)/2;\nfloat kernel[mSize];\nvec3 final_colour = vec3(0.0);\nfloat sigma = 7.0;\nfloat z = 0.0;\nfor (int j = 0; j <= kSize; ++j)\n{\nkernel[kSize+j] = kernel[kSize-j] = normpdf(float(j),sigma);\n}\nfor (int j = 0; j < mSize; ++j)\n{\nz += kernel[j];\n}\nfor (int i = -kSize; i <= kSize; ++i)\n{\nfor (int j = -kSize; j <= kSize; ++j)\n{\nfinal_colour += kernel[kSize+j]*kernel[kSize+i]*texture2D(uSampler, (gl_FragCoord.xy+vec2(float(i),float(j))) / vec2(screenWidth, screenHeight).xy).rgb;\n}\n}\ngl_FragColor = vec4(final_colour/(z*z), 1.0);\n}",
         e
}(egret.CustomFilter), PolygonLightEffect = function(t) {
  function e() { return t.call(this, e.vertSrc, e.fragmentSrc) || this }
  return __extends(e, t),
         e.vertSrc =
             "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nuniform vec2 projectionVector;\nvarying vec2 vTextureCoord;\nconst vec2 center = vec2(-1.0, 1.0);\nvoid main(void) {\n   gl_Position = vec4( (aVertexPosition / projectionVector) + center , 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}",
         e.fragmentSrc =
             "precision lowp float;\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\n#define SAMPLE_COUNT 15\nuniform vec2 _sampleOffsets[SAMPLE_COUNT];\nuniform float _sampleWeights[SAMPLE_COUNT];\nvoid main(void) {\nvec4 c = vec4(0, 0, 0, 0);\nfor( int i = 0; i < SAMPLE_COUNT; i++ )\n   c += texture2D( uSampler, vTextureCoord + _sampleOffsets[i] ) * _sampleWeights[i];\ngl_FragColor = c;\n}",
         e
}(egret.CustomFilter), PostProcessor = function() {
  function t(t) {
    void 0 === t && (t = null), this.enable = !0, this.effect = t
  }
  return t.prototype.onAddedToScene =
             function(t) {
    this.scene = t, this.shape = new egret.Shape,
    this.shape.graphics.beginFill(16777215, 1),
    this.shape.graphics.drawRect(0, 0, SceneManager.stage.stageWidth,
                                 SceneManager.stage.stageHeight),
    this.shape.graphics.endFill(), t.addChild(this.shape)
  },
         t.prototype.process = function() { this.drawFullscreenQuad() },
         t.prototype.onSceneBackBufferSizeChanged = function(t, e) {},
         t.prototype.drawFullscreenQuad =
             function() { this.scene.filters = [ this.effect ] },
         t.prototype.unload =
             function() {
           this.effect && (this.effect = null),
               this.scene.removeChild(this.shape), this.scene = null
         },
         t.default_vert =
             "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec2 aColor;\nuniform vec2 projectionVector;\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nconst vec2 center = vec2(-1.0, 1.0);\nvoid main(void) {\ngl_Position = vec4( (aVertexPosition / projectionVector) + center , 0.0, 1.0);\nvTextureCoord = aTextureCoord;\nvColor = vec4(aColor.x, aColor.x, aColor.x, aColor.x);\n}",
         t
}(), BloomSettings = function() {
  function t(t, e, n, i, o, r) {
    this.threshold = t, this.blurAmount = e, this.intensity = n,
    this.baseIntensity = i, this.saturation = o, this.baseStaturation = r
  }
  return t.presetSettings =
             [
               new t(.1, .6, 2, 1, 1, 0), new t(0, 3, 1, 1, 1, 1),
               new t(.5, 8, 2, 1, 0, 1), new t(.25, 8, 1.3, 1, 1, 0),
               new t(0, 2, 1, .1, 1, 1), new t(.5, 2, 1, 1, 1, 1)
             ],
         t
}(), GaussianBlurPostProcessor = function(t) {
  function e() { return null !== t && t.apply(this, arguments) || this }
  return __extends(e, t), e.prototype.onAddedToScene = function(e) {
    t.prototype.onAddedToScene.call(this, e),
        this.effect = new GaussianBlurEffect
  }, e
}(PostProcessor), Renderer = function() {
  function t() {}
  return t.prototype.onAddedToScene = function(t) {},
         t.prototype.beginRender = function(t) {},
         t.prototype.unload = function() {},
         t.prototype.renderAfterStateCheck = function(t, e) { t.render(e) }, t
}(), DefaultRenderer = function(t) {
  function e() { return null !== t && t.apply(this, arguments) || this }
  return __extends(e, t), e.prototype.render = function(t) {
    var e = this.camera ? this.camera : t.camera;
    this.beginRender(e);
    for (var n = 0; n < t.renderableComponents.count; n++) {
      var i = t.renderableComponents.buffer[n];
      i.enabled && i.isVisibleFromCamera(e) && this.renderAfterStateCheck(i, e)
    }
  }, e
}(Renderer), ScreenSpaceRenderer = function(t) {
  function e() { return null !== t && t.apply(this, arguments) || this }
  return __extends(e, t), e.prototype.render = function(t) {}, e
}(Renderer), PolyLight = function(t) {
  function e(e, n, i) {
    var o = t.call(this) || this;
    return o._indices = [], o.radius = e, o.power = i, o.color = n,
           o.computeTriangleIndices(), o
  }
  return __extends(e, t), Object.defineProperty(e.prototype, "radius", {
    get : function() { return this._radius },
    set : function(t) { this.setRadius(t) },
    enumerable : !0,
    configurable : !0
  }),
         e.prototype
             .computeTriangleIndices =
             function(t) {
           void 0 === t && (t = 20), this._indices.length = 0;
           for (var e = 0; e < t; e += 2)
             this._indices.push(0), this._indices.push(e + 2),
                 this._indices.push(e + 1)
         },
  e.prototype.setRadius = function(
      t) { t != this._radius && (this._radius = t, this._areBoundsDirty = !0) },
  e.prototype.render = function(t) {}, e.prototype.reset = function() {}, e
}(RenderableComponent), SceneTransition = function() {
  function t(t) { this.sceneLoadAction = t, this.loadsNewScene = null != t }
  return Object.defineProperty(t.prototype, "hasPreviousSceneRender", {
    get : function() {
      return !!this._hasPreviousSceneRender ||
             (this._hasPreviousSceneRender = !0, !1)
    },
    enumerable : !0,
    configurable : !0
  }),
         t.prototype.preRender = function() {},
         t.prototype.render = function() {},
         t.prototype.onBeginTransition = function() {
           return __awaiter(this, void 0, void 0, function() {
             return __generator(this, function(t) {
               switch (t.label) {
               case 0:
                 return [ 4, this.loadNextScene() ];
               case 1:
                 return t.sent(), this.transitionComplete(), [ 2 ]
               }
             })
           })
         }, t.prototype.transitionComplete = function() {
           SceneManager.sceneTransition = null,
           this.onTransitionCompleted && this.onTransitionCompleted()
         }, t.prototype.loadNextScene = function() {
           return __awaiter(this, void 0, void 0, function() {
             var t;
             return __generator(this, function(e) {
               switch (e.label) {
               case 0:
                 return this.onScreenObscured && this.onScreenObscured(),
                        this.loadsNewScene || (this.isNewSceneLoaded = !0),
                        t = SceneManager, [ 4, this.sceneLoadAction() ];
               case 1:
                 return t.scene = e.sent(), this.isNewSceneLoaded = !0, [ 2 ]
               }
             })
           })
         }, t.prototype.tickEffectProgressProperty = function(t, e, n, i) {
           return void 0 === i && (i = !1), new Promise(function(o) {
                    var r = i ? 1 : 0, s = i ? 0 : 1;
                    egret.Tween.get(t.uniforms)
                        .set({_progress : r})
                        .to({_progress : s}, 1e3 * e, n)
                        .call(function() { o() })
                  })
         }, t
}(), FadeTransition = function(t) {
  function e(e) {
    var n = t.call(this, e) || this;
    return n.fadeToColor = 0, n.fadeOutDuration = .4,
           n.fadeEaseType = egret.Ease.quadInOut,
           n.delayBeforeFadeInDuration = .1, n._alpha = 0,
           n._mask = new egret.Shape, n
  }
  return __extends(e, t), e.prototype.onBeginTransition = function() {
    return __awaiter(this, void 0, void 0, function() {
      var t = this;
      return __generator(this, function(e) {
        return this._mask.graphics.beginFill(this.fadeToColor, 1),
               this._mask.graphics.drawRect(0, 0, SceneManager.stage.stageWidth,
                                            SceneManager.stage.stageHeight),
               this._mask.graphics.endFill(),
               SceneManager.stage.addChild(this._mask),
               egret.Tween.get(this)
                   .to({_alpha : 1}, 1e3 * this.fadeOutDuration,
                       this.fadeEaseType)
                   .call(function() {
                     return __awaiter(t, void 0, void 0, function() {
                       return __generator(this, function(t) {
                         switch (t.label) {
                         case 0:
                           return [ 4, this.loadNextScene() ];
                         case 1:
                           return t.sent(), [ 2 ]
                         }
                       })
                     })
                   })
                   .wait(this.delayBeforeFadeInDuration)
                   .call(function() {
                     egret.Tween.get(t)
                         .to({_alpha : 0}, 1e3 * t.fadeOutDuration,
                             t.fadeEaseType)
                         .call(function() {
                           t.transitionComplete(),
                               SceneManager.stage.removeChild(t._mask)
                         })
                   }),
               [ 2 ]
      })
    })
  }, e.prototype.render = function() {
    this._mask.graphics.clear(),
        this._mask.graphics.beginFill(this.fadeToColor, this._alpha),
        this._mask.graphics.drawRect(0, 0, SceneManager.stage.stageWidth,
                                     SceneManager.stage.stageHeight),
        this._mask.graphics.endFill()
  }, e
}(SceneTransition), WindTransition = function(t) {
  function e(e) {
    var n = t.call(this, e) || this;
    n.duration = 1, n.easeType = egret.Ease.quadOut;
    return n._windEffect = new egret.CustomFilter(
               "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nuniform vec2 projectionVector;\nvarying vec2 vTextureCoord;\nconst vec2 center = vec2(-1.0, 1.0);\nvoid main(void) {\n   gl_Position = vec4( (aVertexPosition / projectionVector) + center , 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}",
               "precision lowp float;\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float _progress;\nuniform float _size;\nuniform float _windSegments;\nvoid main(void) {\nvec2 co = floor(vec2(0.0, vTextureCoord.y * _windSegments));\nfloat x = sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453;\nfloat r = x - floor(x);\nfloat m = smoothstep(0.0, -_size, vTextureCoord.x * (1.0 - _size) + _size * r - (_progress * (1.0 + _size)));\nvec4 fg = texture2D(uSampler, vTextureCoord);\ngl_FragColor = mix(fg, vec4(0, 0, 0, 0), m);\n}",
               {_progress : 0, _size : .3, _windSegments : 100}),
           n._mask = new egret.Shape, n._mask.graphics.beginFill(16777215, 1),
           n._mask.graphics.drawRect(0, 0, SceneManager.stage.stageWidth,
                                     SceneManager.stage.stageHeight),
           n._mask.graphics.endFill(), n._mask.filters = [ n._windEffect ],
           SceneManager.stage.addChild(n._mask), n
  }
  return __extends(e, t), Object.defineProperty(e.prototype, "windSegments", {
    set : function(t) { this._windEffect.uniforms._windSegments = t },
    enumerable : !0,
    configurable : !0
  }),
         Object.defineProperty(e.prototype, "size", {
           set : function(t) { this._windEffect.uniforms._size = t },
           enumerable : !0,
           configurable : !0
         }),
         e.prototype.onBeginTransition = function() {
           return __awaiter(this, void 0, void 0, function() {
             return __generator(this, function(t) {
               switch (t.label) {
               case 0:
                 return this.loadNextScene(), [
                   4, this.tickEffectProgressProperty(
                          this._windEffect, this.duration, this.easeType)
                 ];
               case 1:
                 return t.sent(), this.transitionComplete(),
                        SceneManager.stage.removeChild(this._mask), [ 2 ]
               }
             })
           })
         }, e
}(SceneTransition), BaseView = function(t) {
  function e() { return null !== t && t.apply(this, arguments) || this }
  return __extends(e, t),
         e.prototype.init = function() {}, e.prototype.show = function(t) {},
         e.prototype.refreshData = function(t) { this._data = t },
         e.prototype.refreshView = function() {},
         e.prototype.close = function() {}, e.prototype.destroy = function() {
           for (this.parent && this.parent.removeChild(this);
                this.numChildren > 0;)
             this.removeChildAt(0)
         }, e
}(egret.DisplayObjectContainer), BaseFuiView = function(t) {
  function e(e) {
    var n = t.call(this) || this;
    return n.name = e, n
  }
  return __extends(e, t), e
}(BaseView), BaseSingle = function() {
  function t() {}
  return t.getInstance = function() {
    return null == this._instance && (this._instance = new this), this._instance
  }, t.prototype.clearFuiObj = function(t) {
    return !!t && (egret.Tween.removeTweens(t.displayObject),
                   t.displayObject && t.displayObject.parent &&
                       t.displayObject.parent.removeChild(t.displayObject),
                   t.dispose(), t = null, !0)
  }, t
}(), ViewManager = function(t) {
  function e() {
    var e = null !== t && t.apply(this, arguments) || this;
    return e._openDic = [], e
  }
  return __extends(e, t), e.prototype.refreshView = function(t, e) {
    var n = this.getView(t);
    n && (n.refreshData(e), n.refreshView())
  }, e.prototype.openView = function(t, e, n) {
    var i = this.getView(t);
    if (i || (i = new t), this.existView(t))
      return i.refreshData(e), void i.refreshView();
    this._openDic.push(i)
  }, e.prototype.getView = function(t) {
    return this._openDic.firstOrDefault(function(e) { return e instanceof t })
  }, e.prototype.existView = function(t) {
    return -1 != this._openDic.findIndex(function(e) { return e instanceof t })
  }, e
}(BaseSingle), Flags = function() {
  function t() {}
  return t.isFlagSet = function(t, e) { return 0 != (t & e) },
         t.isUnshiftedFlagSet = function(t,
                                         e) { return 0 != (t & (e = 1 << e)) },
         t.setFlagExclusive = function(t, e) { return 1 << e },
         t.setFlag = function(t, e) { return t | 1 << e },
         t.unsetFlag = function(t, e) { return t & ~(e = 1 << e) },
         t.invertFlags = function(t) { return ~t }, t
}(), MathHelper = function() {
  function t() {}
  return t.toDegrees = function(t) { return 57.29577951308232 * t },
         t.toRadians = function(t) { return .017453292519943295 * t },
         t.map = function(t, e, n, i,
                          o) { return i + (t - e) * (o - i) / (n - e) },
         t.lerp = function(t, e, n) { return t + (e - t) * n },
         t.clamp = function(t, e, n) { return t < e ? e : t > n ? n : t },
         t.pointOnCirlce =
             function(e, n, i) {
           var o = t.toRadians(i);
           return new Vector2(Math.cos(o) * o + e.x, Math.sin(o) * o + e.y)
         },
         t.isEven = function(t) { return t % 2 == 0 }, t.Epsilon = 1e-5,
         t.Rad2Deg = 57.29578, t.Deg2Rad = .0174532924, t
}(), Matrix2D = function() {
  function t(t, e, n, i, o, r) {
    this.m11 = 0, this.m12 = 0, this.m21 = 0, this.m22 = 0, this.m31 = 0,
    this.m32 = 0, this.m11 = t || 1, this.m12 = e || 0, this.m21 = n || 0,
    this.m22 = i || 1, this.m31 = o || 0, this.m32 = r || 0
  }
  return Object.defineProperty(t, "identity", {
    get : function() { return t._identity },
    enumerable : !0,
    configurable : !0
  }),
         Object.defineProperty(t.prototype, "translation", {
           get : function() { return new Vector2(this.m31, this.m32) },
           set : function(t) { this.m31 = t.x, this.m32 = t.y },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(t.prototype, "rotation", {
           get : function() { return Math.atan2(this.m21, this.m11) },
           set : function(t) {
             var e = Math.cos(t), n = Math.sin(t);
             this.m11 = e, this.m12 = n, this.m21 = -n, this.m22 = e
           },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(t.prototype, "rotationDegrees", {
           get : function() { return MathHelper.toDegrees(this.rotation) },
           set : function(t) { this.rotation = MathHelper.toRadians(t) },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(t.prototype, "scale", {
           get : function() { return new Vector2(this.m11, this.m22) },
           set : function(t) { this.m11 = t.x, this.m12 = t.y },
           enumerable : !0,
           configurable : !0
         }),
         t.add = function(t, e) {
           return t.m11 += e.m11, t.m12 += e.m12, t.m21 += e.m21,
                  t.m22 += e.m22, t.m31 += e.m31, t.m32 += e.m32, t
         }, t.divide = function(t, e) {
           return t.m11 /= e.m11, t.m12 /= e.m12, t.m21 /= e.m21,
                  t.m22 /= e.m22, t.m31 /= e.m31, t.m32 /= e.m32, t
         }, t.multiply = function(e, n) {
           var i = new t, o = e.m11 * n.m11 + e.m12 * n.m21,
               r = e.m11 * n.m12 + e.m12 * n.m22,
               s = e.m21 * n.m11 + e.m22 * n.m21,
               a = e.m21 * n.m12 + e.m22 * n.m22,
               h = e.m31 * n.m11 + e.m32 * n.m21 + n.m31,
               c = e.m31 * n.m12 + e.m32 * n.m22 + n.m32;
           return i.m11 = o, i.m12 = r, i.m21 = s, i.m22 = a, i.m31 = h,
                  i.m32 = c, i
         }, t.multiplyTranslation = function(e, n, i) {
           var o = t.createTranslation(n, i);
           return t.multiply(e, o)
         }, t.prototype.determinant = function() {
           return this.m11 * this.m22 - this.m12 * this.m21
         }, t.invert = function(e, n) {
           void 0 === n && (n = new t);
           var i = 1 / e.determinant();
           return n.m11 = e.m22 * i, n.m12 = -e.m12 * i, n.m21 = -e.m21 * i,
                  n.m22 = e.m11 * i,
                  n.m31 = (e.m32 * e.m21 - e.m31 * e.m22) * i,
                  n.m32 = -(e.m32 * e.m11 - e.m31 * e.m12) * i, n
         }, t.createTranslation = function(e, n, i) {
           return (i = i || new t).m11 = 1, i.m12 = 0, i.m21 = 0, i.m22 = 1,
                                i.m31 = e, i.m32 = n, i
         }, t.createRotation = function(e, n) {
           n = new t;
           var i = Math.cos(e), o = Math.sin(e);
           return n.m11 = i, n.m12 = o, n.m21 = -o, n.m22 = i, n
         }, t.createScale = function(e, n, i) {
           return void 0 === i && (i = new t), i.m11 = e, i.m12 = 0, i.m21 = 0,
                                               i.m22 = n, i.m31 = 0, i.m32 = 0,
                                               i
         }, t.prototype.toEgretMatrix = function() {
           return new egret.Matrix(this.m11, this.m12, this.m21, this.m22,
                                   this.m31, this.m32)
         }, t._identity = new t(1, 0, 0, 1, 0, 0), t
}(), Rectangle = function() {
  function t(t, e, n, i) {
    this.x = t || 0, this.y = e || 0, this.width = n || 0, this.height = i || 0
  }
  return Object.defineProperty(t.prototype, "left", {
    get : function() { return this.x },
    enumerable : !0,
    configurable : !0
  }),
         Object.defineProperty(t.prototype, "right", {
           get : function() { return this.x + this.width },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(t.prototype, "top", {
           get : function() { return this.y },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(t.prototype, "bottom", {
           get : function() { return this.y + this.height },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(t.prototype, "center", {
           get : function() {
             return new Vector2(this.x + this.width / 2,
                                this.y + this.height / 2)
           },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(t.prototype, "location", {
           get : function() { return new Vector2(this.x, this.y) },
           set : function(t) { this.x = t.x, this.y = t.y },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(t.prototype, "size", {
           get : function() { return new Vector2(this.width, this.height) },
           set : function(t) { this.width = t.x, this.height = t.y },
           enumerable : !0,
           configurable : !0
         }),
         t.prototype.intersects = function(t) {
           return t.left < this.right && this.left < t.right &&
                  t.top < this.bottom && this.top < t.bottom
         }, t.prototype.contains = function(t) {
           return this.x <= t.x && t.x < this.x + this.width && this.y <= t.y &&
                  t.y < this.y + this.height
         }, t.prototype.containsRect = function(t) {
           return this.x <= t.x && t.x < this.x + this.width && this.y <= t.y &&
                  t.y < this.y + this.height
         }, t.prototype.getHalfSize = function() {
           return new Vector2(.5 * this.width, .5 * this.height)
         }, t.fromMinMax = function(e, n, i, o) {
           return new t(e, n, i - e, o - n)
         }, t.prototype.getClosestPointOnRectangleBorderToPoint = function(t) {
           var e = new Vector2(0, 0), n = new Vector2(0, 0);
           if (n.x = MathHelper.clamp(t.x, this.left, this.right),
               n.y = MathHelper.clamp(t.y, this.top, this.bottom),
               this.contains(n)) {
             var i = n.x - this.left, o = this.right - n.x, r = n.y - this.top,
                 s = this.bottom - n.y, a = Math.min(i, o, r, s);
             a == r ? (n.y = this.top, e.y = -1)
                    : a == s ? (n.y = this.bottom, e.y = 1)
                             : a == i ? (n.x = this.left, e.x = -1)
                                      : (n.x = this.right, e.x = 1)
           } else
             n.x == this.left && (e.x = -1), n.x == this.right && (e.x = 1),
                 n.y == this.top && (e.y = -1), n.y == this.bottom && (e.y = 1);
           return { res: n, edgeNormal: e }
         }, t.prototype.calculateBounds = function(t, e, n, i, o, r, s) {
           if (0 == o)
             this.x = t.x + e.x - n.x * i.x, this.y = t.y + e.y - n.y * i.y,
             this.width = r * i.x, this.height = s * i.y;
           else {
             var a = t.x + e.x, h = t.y + e.y;
             this._transformMat =
                 Matrix2D.createTranslation(-a - n.x, -h - n.y),
             this._tempMat = Matrix2D.createScale(i.x, i.y),
             this._transformMat =
                 Matrix2D.multiply(this._transformMat, this._tempMat),
             this._tempMat = Matrix2D.createRotation(o),
             this._transformMat =
                 Matrix2D.multiply(this._transformMat, this._tempMat),
             this._tempMat = Matrix2D.createTranslation(a, h),
             this._transformMat =
                 Matrix2D.multiply(this._transformMat, this._tempMat);
             var c = new Vector2(a, h), u = new Vector2(a + r, h),
                 l = new Vector2(a, h + s), p = new Vector2(a + r, h + s);
             c = Vector2Ext.transformR(c, this._transformMat),
             u = Vector2Ext.transformR(u, this._transformMat),
             l = Vector2Ext.transformR(l, this._transformMat),
             p = Vector2Ext.transformR(p, this._transformMat);
             var f = Math.min(c.x, p.x, u.x, l.x),
                 d = Math.max(c.x, p.x, u.x, l.x),
                 y = Math.min(c.y, p.y, u.y, l.y),
                 g = Math.max(c.y, p.y, u.y, l.y);
             this.location = new Vector2(f, y), this.width = d - f,
             this.height = g - y
           }
         }, t.rectEncompassingPoints = function(t) {
           for (var e = Number.POSITIVE_INFINITY, n = Number.POSITIVE_INFINITY,
                    i = Number.NEGATIVE_INFINITY, o = Number.NEGATIVE_INFINITY,
                    r = 0;
                r < t.length; r++) {
             var s = t[r];
             s.x<e && (e = s.x), s.x>i && (i = s.x),
                 s.y<n && (n = s.y), s.y>o && (o = s.y)
           }
           return this.fromMinMax(e, n, i, o)
         }, t
}(), Vector2 = function() {
  function t(t, e) {
    this.x = 0, this.y = 0, this.x = t || 0, this.y = e || this.x
  }
  return Object.defineProperty(t, "zero", {
    get : function() { return t.zeroVector2 },
    enumerable : !0,
    configurable : !0
  }),
         Object.defineProperty(t, "one", {
           get : function() { return t.unitVector2 },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(t, "unitX", {
           get : function() { return t.unitXVector },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(t, "unitY", {
           get : function() { return t.unitYVector },
           enumerable : !0,
           configurable : !0
         }),
         t.add =
             function(e, n) {
           var i = new t(0, 0);
           return i.x = e.x + n.x, i.y = e.y + n.y, i
         },
         t.divide =
             function(e, n) {
           var i = new t(0, 0);
           return i.x = e.x / n.x, i.y = e.y / n.y, i
         },
         t.multiply =
             function(e, n) {
           var i = new t(0, 0);
           return i.x = e.x * n.x, i.y = e.y * n.y, i
         },
         t.subtract =
             function(e, n) {
           var i = new t(0, 0);
           return i.x = e.x - n.x, i.y = e.y - n.y, i
         },
         t.prototype.normalize =
             function() {
           var t = 1 / Math.sqrt(this.x * this.x + this.y * this.y);
           this.x *= t, this.y *= t
         },
         t.prototype.length =
             function() { return Math.sqrt(this.x * this.x + this.y * this.y) },
         t.prototype.round =
             function() {
           return new t(Math.round(this.x), Math.round(this.y))
         },
         t.normalize =
             function(t) {
           var e = 1 / Math.sqrt(t.x * t.x + t.y * t.y);
           return t.x *= e, t.y *= e, t
         },
         t.dot = function(t, e) { return t.x * e.x + t.y * e.y },
         t.distanceSquared =
             function(t, e) {
           var n = t.x - e.x, i = t.y - e.y;
           return n * n + i * i
         },
         t.clamp =
             function(e, n, i) {
           return new t(MathHelper.clamp(e.x, n.x, i.x),
                        MathHelper.clamp(e.y, n.y, i.y))
         },
         t.lerp =
             function(e, n, i) {
           return new t(MathHelper.lerp(e.x, n.x, i),
                        MathHelper.lerp(e.y, n.y, i))
         },
         t.transform =
             function(e, n) {
           return new t(e.x * n.m11 + e.y * n.m21, e.x * n.m12 + e.y * n.m22)
         },
         t.distance =
             function(t, e) {
           var n = t.x - e.x, i = t.y - e.y;
           return Math.sqrt(n * n + i * i)
         },
         t.negate =
             function(e) {
           var n = new t;
           return n.x = -e.x, n.y = -e.y, n
         },
         t.unitYVector = new t(0, 1), t.unitXVector = new t(1, 0),
         t.unitVector2 = new t(1, 1), t.zeroVector2 = new t(0, 0), t
}(), Vector3 = function() {
  return function(t, e, n) { this.x = t, this.y = e, this.z = n }
}(), ColliderTriggerHelper = function() {
  function t(t) {
    this._activeTriggerIntersections = [],
    this._previousTriggerIntersections = [], this._tempTriggerList = [],
    this._entity = t
  }
  return t.prototype.update = function() {
    for (var t = this._entity.getComponents(Collider), e = 0; e < t.length; e++)
      for (var n = t[e],
               i = Physics.boxcastBroadphase(n.bounds, n.collidesWithLayers),
               o =
                   function(t) {
                     var e = i[t];
                     if (!n.isTrigger && !e.isTrigger)
                       return "continue";
                     if (n.overlaps(e)) {
                       var o = new Pair(n, e);
                       -1 == r._activeTriggerIntersections.findIndex(function(
                                 t) {
                         return t.first == o.first && t.second == o.second
                       }) &&
                           -1 == r._previousTriggerIntersections.findIndex(
                                     function(t) {
                                       return t.first == o.first &&
                                              t.second == o.second
                                     }) &&
                           r.notifyTriggerListeners(o, !0),
                           r._activeTriggerIntersections.contains(o) ||
                               r._activeTriggerIntersections.push(o)
                     }
                   },
               r = this, s = 0;
           s < i.length; s++)
        o(s);
    ListPool.free(t), this.checkForExitedColliders()
  }, t.prototype.checkForExitedColliders = function() {
    for (var t = this, e = function(e) {
           var i = n._previousTriggerIntersections.findIndex(function(n) {
             return n.first == t._activeTriggerIntersections[e].first &&
                    n.second == t._activeTriggerIntersections[e].second
           });
           -1 != i && n._previousTriggerIntersections.removeAt(i)
         }, n = this, i = 0; i < this._activeTriggerIntersections.length; i++)
      e(i);
    for (i = 0; i < this._previousTriggerIntersections.length; i++)
      this.notifyTriggerListeners(this._previousTriggerIntersections[i], !1);
    this._previousTriggerIntersections.length = 0;
    for (i = 0; i < this._activeTriggerIntersections.length; i++)
      this._previousTriggerIntersections.contains(
          this._activeTriggerIntersections[i]) ||
          this._previousTriggerIntersections.push(
              this._activeTriggerIntersections[i]);
    this._activeTriggerIntersections.length = 0
  }, t.prototype.notifyTriggerListeners = function(t, e) {
    t.first.entity.getComponents("ITriggerListener", this._tempTriggerList);
    for (var n = 0; n < this._tempTriggerList.length; n++)
      if (e ? this._tempTriggerList[n].onTriggerEnter(t.second, t.first)
            : this._tempTriggerList[n].onTriggerExit(t.second, t.first),
          this._tempTriggerList.length = 0, t.second.entity) {
        t.second.entity.getComponents("ITriggerListener",
                                      this._tempTriggerList);
        for (var i = 0; i < this._tempTriggerList.length; i++)
          e ? this._tempTriggerList[i].onTriggerEnter(t.first, t.second)
            : this._tempTriggerList[i].onTriggerExit(t.first, t.second);
        this._tempTriggerList.length = 0
      }
  }, t
}();
!function(t) {
  t[t.center = 0] = "center", t[t.top = 1] = "top", t[t.bottom = 2] = "bottom",
               t[t.topLeft = 9] = "topLeft", t[t.topRight = 5] = "topRight",
               t[t.left = 8] = "left", t[t.right = 4] = "right",
               t[t.bottomLeft = 10] = "bottomLeft",
               t[t.bottomRight = 6] = "bottomRight"
}(PointSectors || (PointSectors = {}));
var Collisions = function() {
  function t() {}
  return t.isLineToLine = function(t, e, n, i) {
    var o = Vector2.subtract(e, t), r = Vector2.subtract(i, n),
        s = o.x * r.y - o.y * r.x;
    if (0 == s)
      return !1;
    var a = Vector2.subtract(n, t), h = (a.x * r.y - a.y * r.x) / s;
    if (h < 0 || h > 1)
      return !1;
    var c = (a.x * o.y - a.y * o.x) / s;
    return !(c < 0 || c > 1)
  }, t.lineToLineIntersection = function(t, e, n, i) {
    var o = new Vector2(0, 0), r = Vector2.subtract(e, t),
        s = Vector2.subtract(i, n), a = r.x * s.y - r.y * s.x;
    if (0 == a)
      return o;
    var h = Vector2.subtract(n, t), c = (h.x * s.y - h.y * s.x) / a;
    if (c < 0 || c > 1)
      return o;
    var u = (h.x * r.y - h.y * r.x) / a;
    return u < 0 || u > 1 ? o
                          : o = Vector2.add(t, new Vector2(c * r.x, c * r.y))
  }, t.closestPointOnLine = function(t, e, n) {
    var i = Vector2.subtract(e, t), o = Vector2.subtract(n, t),
        r = Vector2.dot(o, i) / Vector2.dot(i, i);
    return r = MathHelper.clamp(r, 0, 1),
           Vector2.add(t, new Vector2(i.x * r, i.y * r))
  }, t.isCircleToCircle = function(t, e, n, i) {
    return Vector2.distanceSquared(t, n) < (e + i) * (e + i)
  }, t.isCircleToLine = function(t, e, n, i) {
    return Vector2.distanceSquared(t, this.closestPointOnLine(n, i, t)) < e * e
  }, t.isCircleToPoint = function(t, e, n) {
    return Vector2.distanceSquared(t, n) < e * e
  }, t.isRectToCircle = function(t, e, n) {
    var i = .5 * t.width, o = .5 * t.height,
        r = Math.max(0, Math.max(e.x - t.x) - i),
        s = Math.max(0, Math.max(e.y - t.y) - o);
    return r * r + s * s < n * n
  }, t.isRectToLine = function(t, e, n) {
    var i = this.getSector(t.x, t.y, t.width, t.height, e),
        o = this.getSector(t.x, t.y, t.width, t.height, n);
    if (i == PointSectors.center || o == PointSectors.center)
      return !0;
    if (0 != (i & o))
      return !1;
    var r = i | o, s = void 0, a = void 0;
    return !(0 == (r & PointSectors.top) ||
             (s = new Vector2(t.x, t.y), a = new Vector2(t.x + t.width, t.y),
              !this.isLineToLine(s, a, e, n))) ||
           (!(0 == (r & PointSectors.bottom) ||
              (s = new Vector2(t.x, t.y + t.height),
               a = new Vector2(t.x + t.width, t.y + t.height),
               !this.isLineToLine(s, a, e, n))) ||
            (!(0 == (r & PointSectors.left) ||
               (s = new Vector2(t.x, t.y), a = new Vector2(t.x, t.y + t.height),
                !this.isLineToLine(s, a, e, n))) ||
             !(0 == (r & PointSectors.right) ||
               (s = new Vector2(t.x + t.width, t.y),
                a = new Vector2(t.x + t.width, t.y + t.height),
                !this.isLineToLine(s, a, e, n)))))
  }, t.isRectToPoint = function(t, e, n, i, o) {
    return o.x >= t && o.y >= e && o.x < t + n && o.y < e + i
  }, t.getSector = function(t, e, n, i, o) {
    var r = PointSectors.center;
    return o.x < t ? r |= PointSectors.left
                   : o.x >= t + n && (r |= PointSectors.right),
           o.y < e ? r |= PointSectors.top
                   : o.y >= e + i && (r |= PointSectors.bottom),
           r
  }, t
}(), Physics = function() {
  function t() {}
  return t.reset =
             function() {
    this._spatialHash = new SpatialHash(this.spatialHashCellSize)
  },
         t.clear = function() { this._spatialHash.clear() },
         t.overlapCircleAll =
             function(t, e, n, i) {
           return void 0 === i && (i = -1),
                  this._spatialHash.overlapCircle(t, e, n, i)
         },
         t.boxcastBroadphase =
             function(t, e) {
           return void 0 === e && (e = this.allLayers),
                  this._spatialHash.aabbBroadphase(t, null, e)
         },
         t.boxcastBroadphaseExcludingSelf =
             function(t, e, n) {
           return void 0 === n && (n = this.allLayers),
                  this._spatialHash.aabbBroadphase(e, t, n)
         },
         t.addCollider = function(e) { t._spatialHash.register(e) },
         t.removeCollider = function(e) { t._spatialHash.remove(e) },
         t.updateCollider = function(
             t) { this._spatialHash.remove(t), this._spatialHash.register(t) },
         t.spatialHashCellSize = 100, t.allLayers = -1, t
}(), Shape = function() { return function() {} }(), Polygon = function(t) {
  function e(e, n) {
    var i = t.call(this) || this;
    return i.isUnrotated = !0, i._areEdgeNormalsDirty = !0, i.setPoints(e),
           i.isBox = n, i
  }
  return __extends(e, t), Object.defineProperty(e.prototype, "edgeNormals", {
    get : function() {
      return this._areEdgeNormalsDirty && this.buildEdgeNormals(),
             this._edgeNormals
    },
    enumerable : !0,
    configurable : !0
  }),
         e.prototype.buildEdgeNormals = function() {
           var t, e = this.isBox ? 2 : this.points.length;
           null != this._edgeNormals && this._edgeNormals.length == e ||
               (this._edgeNormals = new Array(e));
           for (var n = 0; n < e; n++) {
             var i = this.points[n];
             t = n + 1 >= this.points.length ? this.points[0]
                                             : this.points[n + 1];
             var o = Vector2Ext.perpendicular(i, t);
             o = Vector2.normalize(o), this._edgeNormals[n] = o
           }
         }, e.prototype.setPoints = function(t) {
           this.points = t, this.recalculateCenterAndEdgeNormals(),
           this._originalPoints = [];
           for (var e = 0; e < this.points.length; e++)
             this._originalPoints.push(this.points[e])
         }, e.prototype.collidesWithShape = function(t) {
           var n = new CollisionResult;
           if (t instanceof e)
             return ShapeCollisions.polygonToPolygon(this, t);
           if (t instanceof Circle)
             return (n = ShapeCollisions.circleToPolygon(t, this))
                        ? (n.invertResult(), n)
                        : null;
           throw new Error("overlaps of Polygon to " + t + " are not supported")
         }, e.prototype.recalculateCenterAndEdgeNormals = function() {
           this._polygonCenter = e.findPolygonCenter(this.points),
           this._areEdgeNormalsDirty = !0
         }, e.prototype.overlaps = function(t) {
           var n;
           if (t instanceof e)
             return ShapeCollisions.polygonToPolygon(this, t);
           if (t instanceof Circle)
             return !!(n = ShapeCollisions.circleToPolygon(t, this)) &&
                    (n.invertResult(), !0);
           throw new Error("overlaps of Pologon to " + t + " are not supported")
         }, e.findPolygonCenter = function(t) {
           for (var e = 0, n = 0, i = 0; i < t.length; i++)
             e += t[i].x, n += t[i].y;
           return new Vector2(e / t.length, n / t.length)
         }, e.getClosestPointOnPolygonToPoint = function(t, e) {
           for (var n, i = Number.MAX_VALUE, o = new Vector2(0, 0),
                       r = new Vector2(0, 0), s = 0;
                s < t.length; s++) {
             var a = s + 1;
             a == t.length && (a = 0);
             var h = ShapeCollisions.closestPointOnLine(t[s], t[a], e);
             if ((n = Vector2.distanceSquared(e, h)) < i) {
               i = n, r = h;
               var c = Vector2.subtract(t[a], t[s]);
               o.x = -c.y, o.y = c.x
             }
           }
           return {
             closestPoint: r, distanceSquared: i,
                 edgeNormal: o = Vector2.normalize(o)
           }
         }, e.prototype.pointCollidesWithShape = function(t) {
           return ShapeCollisions.pointToPoly(t, this)
         }, e.prototype.containsPoint = function(t) {
           t = Vector2.subtract(t, this.position);
           for (var e = !1, n = 0, i = this.points.length - 1;
                n < this.points.length; i = n++)
             this.points[n].y > t.y != this.points[i].y > t.y &&
                 t.x < (this.points[i].x - this.points[n].x) *
                               (t.y - this.points[n].y) /
                               (this.points[i].y - this.points[n].y) +
                           this.points[n].x &&
                 (e = !e);
           return e
         }, e.buildSymmertricalPolygon = function(t, e) {
           for (var n = new Array(t), i = 0; i < t; i++) {
             var o = 2 * Math.PI * (i / t);
             n[i] = new Vector2(Math.cos(o), Math.sin(o) * e)
           }
           return n
         }, e.prototype.recalculateBounds = function(t) {
           if (this.center = t.localOffset,
               t.shouldColliderScaleAndRotationWithTransform) {
             var e = !0, n = void 0,
                 i = Matrix2D.createTranslation(-this._polygonCenter.x,
                                                -this._polygonCenter.y);
             if (t.entity.scale != Vector2.one) {
               n = Matrix2D.createScale(t.entity.scale.x, t.entity.scale.y),
               i = Matrix2D.multiply(i, n), e = !1;
               var o = Vector2.multiply(t.localOffset, t.entity.scale);
               this.center = o
             }
             if (0 != t.entity.rotation) {
               n = Matrix2D.createRotation(t.entity.rotation),
               i = Matrix2D.multiply(i, n);
               var r = Math.atan2(t.localOffset.y, t.localOffset.x) *
                       MathHelper.Rad2Deg,
                   s = e ? t._localOffsetLength
                         : Vector2.multiply(t.localOffset, t.entity.scale)
                               .length();
               this.center = MathHelper.pointOnCirlce(
                   Vector2.zero, s, MathHelper.toDegrees(t.entity.rotation) + r)
             }
             n = Matrix2D.createTranslation(this._polygonCenter.x,
                                            this._polygonCenter.y),
             i = Matrix2D.multiply(i, n),
             Vector2Ext.transform(this._originalPoints, i, this.points),
             this.isUnrotated = 0 == t.entity.rotation,
             t._isRotationDirty && (this._areEdgeNormalsDirty = !0)
           }
           this.position = Vector2.add(t.entity.position, this.center),
           this.bounds = Rectangle.rectEncompassingPoints(this.points),
           this.bounds.location =
               Vector2.add(this.bounds.location, this.position)
         }, e
}(Shape), Box = function(t) {
  function e(n, i) {
    var o = t.call(this, e.buildBox(n, i), !0) || this;
    return o.width = n, o.height = i, o
  }
  return __extends(e, t), e.buildBox = function(t, e) {
    var n = t / 2, i = e / 2, o = new Array(4);
    return o[0] = new Vector2(-n, -i), o[1] = new Vector2(n, -i),
           o[2] = new Vector2(n, i), o[3] = new Vector2(-n, i), o
  }, e.prototype.updateBox = function(t, e) {
    this.width = t, this.height = e;
    var n = t / 2, i = e / 2;
    this.points[0] = new Vector2(-n, -i), this.points[1] = new Vector2(n, -i),
    this.points[2] = new Vector2(n, i), this.points[3] = new Vector2(-n, i);
    for (var o = 0; o < this.points.length; o++)
      this._originalPoints[o] = this.points[o]
  }, e.prototype.containsPoint = function(e) {
    return this.isUnrotated ? this.bounds.contains(e)
                            : t.prototype.containsPoint.call(this, e)
  }, e
}(Polygon), Circle = function(t) {
  function e(e) {
    var n = t.call(this) || this;
    return n.radius = e, n._originalRadius = e, n
  }
  return __extends(e, t), e.prototype.pointCollidesWithShape = function(t) {
    return ShapeCollisions.pointToCircle(t, this)
  }, e.prototype.collidesWithShape = function(t) {
    if (t instanceof Box && t.isUnrotated)
      return ShapeCollisions.circleToBox(this, t);
    if (t instanceof e)
      return ShapeCollisions.circleToCircle(this, t);
    if (t instanceof Polygon)
      return ShapeCollisions.circleToPolygon(this, t);
    throw new Error("Collisions of Circle to " + t + " are not supported")
  }, e.prototype.recalculateBounds = function(t) {
    if (this.center = t.localOffset,
        t.shouldColliderScaleAndRotationWithTransform) {
      var e = t.entity.scale, n = 1 == e.x && 1 == e.y, i = Math.max(e.x, e.y);
      if (this.radius = this._originalRadius * i, 0 != t.entity.rotation) {
        var o = Math.atan2(t.localOffset.y, t.localOffset.x) *
                MathHelper.Rad2Deg,
            r = n ? t._localOffsetLength
                  : Vector2.multiply(t.localOffset, t.entity.scale).length();
        this.center = MathHelper.pointOnCirlce(
            Vector2.zero, r, MathHelper.toDegrees(t.entity.rotation) + o)
      }
    }
    this.position = Vector2.add(t.entity.position, this.center),
    this.bounds = new Rectangle(this.position.x - this.radius,
                                this.position.y - this.radius, 2 * this.radius,
                                2 * this.radius)
  }, e.prototype.overlaps = function(t) {
    if (t instanceof Box && t.isUnrotated)
      return Collisions.isRectToCircle(t.bounds, this.position, this.radius);
    if (t instanceof e)
      return Collisions.isCircleToCircle(this.position, this.radius, t.position,
                                         t.radius);
    if (t instanceof Polygon)
      return ShapeCollisions.circleToPolygon(this, t);
    throw new Error("overlaps of circle to " + t + " are not supported")
  }, e
}(Shape), CollisionResult = function() {
  function t() {}
  return t.prototype.invertResult = function() {
    this.minimumTranslationVector =
        Vector2.negate(this.minimumTranslationVector),
    this.normal = Vector2.negate(this.normal)
  }, t
}(), ShapeCollisions = function() {
  function t() {}
  return t.polygonToPolygon = function(t, e) {
    for (var n, i = new CollisionResult, o = !0, r = t.edgeNormals,
                s = e.edgeNormals, a = Number.POSITIVE_INFINITY,
                h = new Vector2, c = Vector2.subtract(t.position, e.position),
                u = 0;
         u < r.length + s.length; u++) {
      n = u < r.length ? r[u] : s[u - r.length];
      var l = 0, p = 0, f = 0, d = 0, y = 0, g = this.getInterval(n, t, l, f);
      l = g.min, p = g.max;
      var m = this.getInterval(n, e, p, d);
      p = m.min, d = m.max;
      var _ = Vector2.dot(c, n);
      if (l += _, f += _,
          (y = this.intervalDistance(l, f, p, d)) > 0 && (o = !1), !o)
        return null;
      (y = Math.abs(y)) < a &&
          (a = y, h = n, Vector2.dot(h, c) < 0 && (h = new Vector2(-h)))
    }
    return i.normal = h,
           i.minimumTranslationVector =
               Vector2.multiply(new Vector2(-h), new Vector2(a)),
           i
  }, t.intervalDistance = function(t, e, n, i) {
    return t < n ? n - e : t - n
  }, t.getInterval = function(t, e, n, i) {
    var o = Vector2.dot(e.points[0], t);
    n = i = o;
    for (var r = 1; r < e.points.length; r++)
      (o = Vector2.dot(e.points[r], t))<n ? n = o : o>i && (i = o);
    return { min: n, max: i }
  }, t.circleToPolygon = function(t, e) {
    var n = new CollisionResult, i = Vector2.subtract(t.position, e.position),
        o = Polygon.getClosestPointOnPolygonToPoint(e.points, i),
        r = o.closestPoint, s = o.distanceSquared;
    n.normal = o.edgeNormal;
    var a, h = e.containsPoint(t.position);
    if (s > t.radius * t.radius && !h)
      return null;
    if (h)
      a = Vector2.multiply(n.normal, new Vector2(Math.sqrt(s) - t.radius));
    else if (0 == s)
      a = Vector2.multiply(n.normal, new Vector2(t.radius));
    else {
      var c = Math.sqrt(s);
      a = Vector2.multiply(new Vector2(-Vector2.subtract(i, r)),
                           new Vector2((t.radius - s) / c))
    }
    return n.minimumTranslationVector = a, n.point = Vector2.add(r, e.position),
           n
  }, t.circleToBox = function(t, e) {
    var n = new CollisionResult,
        i = e.bounds.getClosestPointOnRectangleBorderToPoint(t.position).res;
    if (e.containsPoint(t.position)) {
      n.point = i;
      var o = Vector2.add(i, Vector2.subtract(n.normal, new Vector2(t.radius)));
      return n.minimumTranslationVector = Vector2.subtract(t.position, o), n
    }
    var r = Vector2.distanceSquared(i, t.position);
    if (0 == r)
      n.minimumTranslationVector =
          Vector2.multiply(n.normal, new Vector2(t.radius));
    else if (r <= t.radius * t.radius) {
      n.normal = Vector2.subtract(t.position, i);
      var s = n.normal.length() - t.radius;
      return n.normal = Vector2Ext.normalize(n.normal),
             n.minimumTranslationVector =
                 Vector2.multiply(new Vector2(s), n.normal),
             n
    }
    return null
  }, t.pointToCircle = function(t, e) {
    var n = new CollisionResult, i = Vector2.distanceSquared(t, e.position),
        o = 1 + e.radius;
    if (i < o * o) {
      n.normal = Vector2.normalize(Vector2.subtract(t, e.position));
      var r = o - Math.sqrt(i);
      return n.minimumTranslationVector =
                 Vector2.multiply(new Vector2(-r, -r), n.normal),
             n.point = Vector2.add(
                 e.position,
                 Vector2.multiply(n.normal, new Vector2(e.radius, e.radius))),
             n
    }
    return null
  }, t.closestPointOnLine = function(t, e, n) {
    var i = Vector2.subtract(e, t), o = Vector2.subtract(n, t),
        r = Vector2.dot(o, i) / Vector2.dot(i, i);
    return r = MathHelper.clamp(r, 0, 1),
           Vector2.add(t, Vector2.multiply(i, new Vector2(r, r)))
  }, t.pointToPoly = function(t, e) {
    var n = new CollisionResult;
    if (e.containsPoint(t)) {
      var i,
          o = Polygon.getClosestPointOnPolygonToPoint(
              e.points, Vector2.subtract(t, e.position)),
          r = o.closestPoint;
      return i = o.distanceSquared, n.normal = o.edgeNormal,
             n.minimumTranslationVector = Vector2.multiply(
                 n.normal, new Vector2(Math.sqrt(i), Math.sqrt(i))),
             n.point = Vector2.add(r, e.position), n
    }
    return null
  }, t.circleToCircle = function(t, e) {
    var n = new CollisionResult,
        i = Vector2.distanceSquared(t.position, e.position),
        o = t.radius + e.radius;
    if (i < o * o) {
      n.normal = Vector2.normalize(Vector2.subtract(t.position, e.position));
      var r = o - Math.sqrt(i);
      return n.minimumTranslationVector =
                 Vector2.multiply(new Vector2(-r), n.normal),
             n.point = Vector2.add(
                 e.position, Vector2.multiply(n.normal, new Vector2(e.radius))),
             n
    }
    return null
  }, t
}(), SpatialHash = function() {
  function t(t) {
    void 0 === t && (t = 100),
        this.gridBounds = new Rectangle, this._tempHashSet = [],
        this._cellDict = new NumberDictionary, this._cellSize = t,
        this._inverseCellSize = 1 / this._cellSize,
        this._raycastParser = new RaycastResultParser
  }
  return t.prototype.remove = function(t) {
    for (var e = t.registeredPhysicsBounds, n = this.cellCoords(e.x, e.y),
             i = this.cellCoords(e.right, e.bottom), o = n.x;
         o <= i.x; o++)
      for (var r = n.y; r <= i.y; r++) {
        var s = this.cellAtPosition(o, r);
        s ? s.remove(t)
          : console.error("removing Collider [" + t +
                          "] from a cell that it is not present in")
      }
  }, t.prototype.register = function(t) {
    var e = t.bounds;
    t.registeredPhysicsBounds = e;
    var n = this.cellCoords(e.x, e.y), i = this.cellCoords(e.right, e.bottom);
    this.gridBounds.contains(new Vector2(n.x, n.y)) ||
        (this.gridBounds = RectangleExt.union(this.gridBounds, n)),
        this.gridBounds.contains(new Vector2(i.x, i.y)) ||
            (this.gridBounds = RectangleExt.union(this.gridBounds, i));
    for (var o = n.x; o <= i.x; o++)
      for (var r = n.y; r <= i.y; r++) {
        this.cellAtPosition(o, r, !0).push(t)
      }
  }, t.prototype.clear = function() {
    this._cellDict.clear()
  }, t.prototype.overlapCircle = function(t, e, n, i) {
    var o = new Rectangle(t.x - e, t.y - e, 2 * e, 2 * e);
    this._overlapTestCircle.radius = e, this._overlapTestCircle.position = t;
    for (var r = 0, s = this.aabbBroadphase(o, null, i), a = 0; a < s.length;
         a++) {
      var h = s[a];
      if (!(h instanceof BoxCollider))
        throw new Error(
            "overlapCircle against this collider type is not implemented!");
      if (n[r] = h, ++r == n.length)
        return r
    }
    return r
  }, t.prototype.aabbBroadphase = function(t, e, n) {
    this._tempHashSet.length = 0;
    for (var i = this.cellCoords(t.x, t.y),
             o = this.cellCoords(t.right, t.bottom), r = i.x;
         r <= o.x; r++)
      for (var s = i.y; s <= o.y; s++) {
        var a = this.cellAtPosition(r, s);
        if (a)
          for (var h = 0; h < a.length; h++) {
            var c = a[h];
            c != e && Flags.isFlagSet(n, c.physicsLayer) &&
                (t.intersects(c.bounds) && -1 == this._tempHashSet.indexOf(c) &&
                 this._tempHashSet.push(c))
          }
      }
    return this._tempHashSet
  }, t.prototype.cellAtPosition = function(t, e, n) {
    void 0 === n && (n = !1);
    var i = this._cellDict.tryGetValue(t, e);
    return i || n && (i = [], this._cellDict.add(t, e, i)), i
  }, t.prototype.cellCoords = function(t, e) {
    return new Point(Math.floor(t * this._inverseCellSize),
                     Math.floor(e * this._inverseCellSize))
  }, t
}(), RaycastResultParser = function() {
  return function() {}
}(), NumberDictionary = function() {
  function t() { this._store = new Map }
  return t.prototype
             .getKey =
             function(t, e) {
    return Long.fromNumber(t).shiftLeft(32).or(this.intToUint(e)).toString()
  },
  t.prototype.intToUint = function(t) { return t >= 0 ? t : 4294967296 + t },
  t.prototype.add = function(t, e, n) { this._store.set(this.getKey(t, e), n) },
  t.prototype.remove = function(
      t) { this._store.forEach(function(e) { e.contains(t) && e.remove(t) }) },
  t.prototype.tryGetValue = function(
      t, e) { return this._store.get(this.getKey(t, e)) },
  t.prototype.clear = function() { this._store.clear() }, t
}(), ContentManager = function() {
  function t() { this.loadedAssets = new Map }
  return t.prototype.loadRes = function(t, e) {
    var n = this;
    return void 0 === e && (e = !0), new Promise(function(i, o) {
             var r = n.loadedAssets.get(t);
             r ? i(r)
               : e ? RES.getResAsync(t)
                         .then(function(e) { n.loadedAssets.set(t, e), i(e) })
                         .catch(function(
                             e) { console.error("资源加载错误:", t, e), o(e) })
                   : RES.getResByUrl(t)
                         .then(function(e) { n.loadedAssets.set(t, e), i(e) })
                         .catch(function(
                             e) { console.error("资源加载错误:", t, e), o(e) })
           })
  }, t.prototype.dispose = function() {
    this.loadedAssets.forEach(function(t) { t.dispose() }),
        this.loadedAssets.clear()
  }, t
}(), Emitter = function() {
  function t() { this._messageTable = new Map }
  return t.prototype.addObserver = function(t, e) {
    var n = this._messageTable.get(t);
    n || (n = [], this._messageTable.set(t, n)),
        n.contains(e) && console.warn("您试图添加相同的观察者两次"), n.push(e)
  }, t.prototype.removeObserver = function(t, e) {
    this._messageTable.get(t).remove(e)
  }, t.prototype.emit = function(t, e) {
    var n = this._messageTable.get(t);
    if (n)
      for (var i = n.length - 1; i >= 0; i--)
        n[i](e)
  }, t
}(), GlobalManager = function() {
  function t() {}
  return Object.defineProperty(t.prototype, "enabled", {
    get : function() { return this._enabled },
    set : function(t) { this.setEnabled(t) },
    enumerable : !0,
    configurable : !0
  }),
         t.prototype.setEnabled =
             function(t) {
           this._enabled != t &&
               (this._enabled = t,
                this._enabled ? this.onEnabled() : this.onDisabled())
         },
         t.prototype.onEnabled = function() {},
         t.prototype.onDisabled = function() {},
         t.prototype.update = function() {},
         t.registerGlobalManager = function(
             t) { this.globalManagers.push(t), t.enabled = !0 },
         t.unregisterGlobalManager = function(
             t) { this.globalManagers.remove(t), t.enabled = !1 },
         t.getGlobalManager = function(t) {
           for (var e = 0; e < this.globalManagers.length; e++)
             if (this.globalManagers[e] instanceof t)
               return this.globalManagers[e];
           return null
         }, t.globalManagers = [], t
}(), TouchState = function() {
  function t() {
    this.x = 0, this.y = 0, this.touchPoint = -1, this.touchDown = !1
  }
  return Object.defineProperty(t.prototype, "position", {
    get : function() { return new Vector2(this.x, this.y) },
    enumerable : !0,
    configurable : !0
  }),
         t.prototype.reset = function() {
           this.x = 0, this.y = 0, this.touchDown = !1, this.touchPoint = -1
         }, t
}(), Input = function() {
  function t() {}
  return Object.defineProperty(t, "touchPosition", {
    get : function() {
      return this._gameTouchs[0] ? this._gameTouchs[0].position : Vector2.zero
    },
    enumerable : !0,
    configurable : !0
  }),
         Object.defineProperty(t, "maxSupportedTouch", {
           get : function() { return this._stage.maxTouches },
           set : function(
               t) { this._stage.maxTouches = t, this.initTouchCache() },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(t, "resolutionScale", {
           get : function() { return this._resolutionScale },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(t, "totalTouchCount", {
           get : function() { return this._totalTouchCount },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(t, "gameTouchs", {
           get : function() { return this._gameTouchs },
           enumerable : !0,
           configurable : !0
         }),
         Object.defineProperty(t, "touchPositionDelta", {
           get : function() {
             var t = Vector2.subtract(this.touchPosition,
                                      this._previousTouchState.position);
             return t.length() > 0 &&
                        this.setpreviousTouchState(this._gameTouchs[0]),
                    t
           },
           enumerable : !0,
           configurable : !0
         }),
         t.initialize =
             function(t) {
           this._init ||
               (this._init = !0, this._stage = t,
                this._stage.addEventListener(egret.TouchEvent.TOUCH_BEGIN,
                                             this.touchBegin, this),
                this._stage.addEventListener(egret.TouchEvent.TOUCH_MOVE,
                                             this.touchMove, this),
                this._stage.addEventListener(egret.TouchEvent.TOUCH_END,
                                             this.touchEnd, this),
                this._stage.addEventListener(egret.TouchEvent.TOUCH_CANCEL,
                                             this.touchEnd, this),
                this._stage.addEventListener(
                    egret.TouchEvent.TOUCH_RELEASE_OUTSIDE, this.touchEnd,
                    this),
                this.initTouchCache())
         },
         t.initTouchCache =
             function() {
           this._totalTouchCount = 0, this._touchIndex = 0,
           this._gameTouchs.length = 0;
           for (var t = 0; t < this.maxSupportedTouch; t++)
             this._gameTouchs.push(new TouchState)
         },
         t.touchBegin =
             function(t) {
           this._touchIndex < this.maxSupportedTouch &&
               (this._gameTouchs[this._touchIndex].touchPoint = t.touchPointID,
                this._gameTouchs[this._touchIndex].touchDown = t.touchDown,
                this._gameTouchs[this._touchIndex].x = t.stageX,
                this._gameTouchs[this._touchIndex].y = t.stageY,
                0 == this._touchIndex &&
                    this.setpreviousTouchState(this._gameTouchs[0]),
                this._touchIndex++, this._totalTouchCount++)
         },
         t.touchMove =
             function(t) {
           t.touchPointID == this._gameTouchs[0].touchPoint &&
               this.setpreviousTouchState(this._gameTouchs[0]);
           var e = this._gameTouchs.findIndex(function(
               e) { return e.touchPoint == t.touchPointID });
           if (-1 != e) {
             var n = this._gameTouchs[e];
             n.x = t.stageX, n.y = t.stageY
           }
         },
         t.touchEnd =
             function(t) {
           var e = this._gameTouchs.findIndex(function(
               e) { return e.touchPoint == t.touchPointID });
           -1 != e && (this._gameTouchs[e].reset(),
                       0 == e && this._previousTouchState.reset(),
                       this._totalTouchCount--,
                       0 == this.totalTouchCount && (this._touchIndex = 0))
         },
         t.setpreviousTouchState =
             function(t) {
           this._previousTouchState = new TouchState,
           this._previousTouchState.x = t.position.x,
           this._previousTouchState.y = t.position.y,
           this._previousTouchState.touchPoint = t.touchPoint,
           this._previousTouchState.touchDown = t.touchDown
         },
         t.scaledPosition =
             function(t) {
           var e = new Vector2(t.x - this._resolutionOffset.x,
                               t.y - this._resolutionOffset.y);
           return Vector2.multiply(e, this.resolutionScale)
         },
         t._init = !1, t._previousTouchState = new TouchState,
         t._gameTouchs = [], t._resolutionOffset = new Vector2,
         t._resolutionScale = Vector2.one, t._touchIndex = 0,
         t._totalTouchCount = 0, t
}(), ListPool = function() {
  function t() {}
  return t.warmCache = function(t) {
    if ((t -= this._objectQueue.length) > 0)
      for (var e = 0; e < t; e++)
        this._objectQueue.unshift([])
  }, t.trimCache = function(t) {
    for (; t > this._objectQueue.length;)
      this._objectQueue.shift()
  }, t.clearCache = function() {
    this._objectQueue.length = 0
  }, t.obtain = function() {
    return this._objectQueue.length > 0 ? this._objectQueue.shift() : []
  }, t.free = function(t) {
    this._objectQueue.unshift(t), t.length = 0
  }, t._objectQueue = [], t
}(), Pair = function() {
  function t(t, e) { this.first = t, this.second = e }
  return t.prototype.clear = function() { this.first = this.second = null },
         t.prototype.equals = function(
             t) { return this.first == t.first && this.second == t.second },
         t
}(), RectangleExt = function() {
  function t() {}
  return t.union = function(t, e) {
    var n = new Rectangle(e.x, e.y, 0, 0);
    return this.unionR(t, n)
  }, t.unionR = function(t, e) {
    var n = new Rectangle;
    return n.x = Math.min(t.x, e.x), n.y = Math.min(t.y, e.y),
           n.width = Math.max(t.right, e.right) - n.x,
           n.height = Math.max(t.bottom, e.bottom) - n.y, n
  }, t
}(), Triangulator = function() {
  function t() {
    this.triangleIndices = [], this._triPrev = new Array(12),
    this._triNext = new Array(12)
  }
  return t.prototype.triangulate = function(e, n) {
    void 0 === n && (n = !0);
    var i = e.length;
    this.initialize(i);
    for (var o = 0, r = 0; i > 3 && o < 500;) {
      o++;
      var s = !0, a = e[this._triPrev[r]], h = e[r], c = e[this._triNext[r]];
      if (Vector2Ext.isTriangleCCW(a, h, c)) {
        var u = this._triNext[this._triNext[r]];
        do {
          if (t.testPointTriangle(e[u], a, h, c)) {
            s = !1;
            break
          }
          u = this._triNext[u]
        } while (u != this._triPrev[r])
      } else
        s = !1;
      s ? (this.triangleIndices.push(this._triPrev[r]),
           this.triangleIndices.push(r),
           this.triangleIndices.push(this._triNext[r]),
           this._triNext[this._triPrev[r]] = this._triNext[r],
           this._triPrev[this._triNext[r]] = this._triPrev[r], i--,
           r = this._triPrev[r])
        : r = this._triNext[r]
    }
    this.triangleIndices.push(this._triPrev[r]), this.triangleIndices.push(r),
        this.triangleIndices.push(this._triNext[r]),
        n || this.triangleIndices.reverse()
  }, t.prototype.initialize = function(t) {
    this.triangleIndices.length = 0,
    this._triNext.length < t &&
        (this._triNext.reverse(),
         this._triNext = new Array(Math.max(2 * this._triNext.length, t))),
    this._triPrev.length < t &&
        (this._triPrev.reverse(),
         this._triPrev = new Array(Math.max(2 * this._triPrev.length, t)));
    for (var e = 0; e < t; e++)
      this._triPrev[e] = e - 1, this._triNext[e] = e + 1;
    this._triPrev[0] = t - 1, this._triNext[t - 1] = 0
  }, t.testPointTriangle = function(t, e, n, i) {
    return !(Vector2Ext.cross(Vector2.subtract(t, e), Vector2.subtract(n, e)) <
             0) &&
           (!(Vector2Ext.cross(Vector2.subtract(t, n), Vector2.subtract(i, n)) <
              0) &&
            !(Vector2Ext.cross(Vector2.subtract(t, i), Vector2.subtract(e, i)) <
              0))
  }, t
}(), Vector2Ext = function() {
  function t() {}
  return t.isTriangleCCW =
             function(t, e, n) {
    return this.cross(Vector2.subtract(e, t), Vector2.subtract(n, e)) < 0
  },
         t.cross = function(t, e) { return t.y * e.x - t.x * e.y },
         t.perpendicular = function(
             t, e) { return new Vector2(-1 * (e.y - t.y), e.x - t.x) },
         t.normalize = function(t) {
           var e = Math.sqrt(t.x * t.x + t.y * t.y);
           return e > MathHelper.Epsilon ? t = Vector2.divide(t, new Vector2(e))
                                         : t.x = t.y = 0,
                                           t
         }, t.transformA = function(t, e, n, i, o, r) {
           for (var s = 0; s < r; s++) {
             var a = t[e + s], h = i[o + s];
             h.x = a.x * n.m11 + a.y * n.m21 + n.m31,
             h.y = a.x * n.m12 + a.y * n.m22 + n.m32, i[o + s] = h
           }
         }, t.transformR = function(t, e) {
           var n = t.x * e.m11 + t.y * e.m21 + e.m31,
               i = t.x * e.m12 + t.y * e.m22 + e.m32;
           return new Vector2(n, i)
         }, t.transform = function(t, e, n) {
           this.transformA(t, 0, e, n, 0, t.length)
         }, t.round = function(t) {
           return new Vector2(Math.round(t.x), Math.round(t.y))
         }, t
}();